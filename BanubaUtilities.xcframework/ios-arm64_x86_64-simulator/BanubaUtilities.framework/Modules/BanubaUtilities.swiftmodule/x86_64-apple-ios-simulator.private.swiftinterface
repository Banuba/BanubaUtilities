// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target x86_64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name BanubaUtilities
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import Accelerate
@_exported import BanubaUtilities
import CloudKit
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreMedia
import Foundation
import Foundation/*.NSRecursiveLock*/
import ImageIO
import MobileCoreServices
import Photos
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
import os.log
import os
public protocol ImageButtonConfigurationProtocol {
  var imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol { get set }
  var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? { get set }
}
public struct BanubaImageButtonConfiguration : BanubaUtilities.ImageButtonConfigurationProtocol {
  public var imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)?
  public init(imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol, selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? = nil)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class AlertViewController : UIKit.UIViewController, BanubaUtilities.NibLoadable {
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var contextView: UIKit.UIView!
  @objc @IBOutlet @_Concurrency.MainActor(unsafe) weak public var backgroundView: UIKit.UIView!
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  public enum AlertType {
    case info
    case selection(_: Swift.String?, _: Swift.String?)
    case reset(_: Swift.String?, _: Swift.String?, _: Swift.String?)
    case missedPermission
  }
  public enum ButtonType {
    case agreeButton
    case refuseButton
    case additionalButton
    public static func == (a: BanubaUtilities.AlertViewController.ButtonType, b: BanubaUtilities.AlertViewController.ButtonType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var titleText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var messageText: Swift.String? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var alertType: BanubaUtilities.AlertViewController.AlertType? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: BanubaUtilities.AlertViewConfiguration?
  @_Concurrency.MainActor(unsafe) public var actionHandler: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum KingfisherError : Swift.Error {
  public enum RequestErrorReason {
    case emptyRequest
    case invalidURL(request: Foundation.URLRequest)
    case taskCancelled(task: BanubaUtilities.SessionDataTask, token: BanubaUtilities.SessionDataTask.CancelToken)
  }
  public enum ResponseErrorReason {
    case invalidURLResponse(response: Foundation.URLResponse)
    case invalidHTTPStatusCode(response: Foundation.HTTPURLResponse)
    case URLSessionError(error: any Swift.Error)
    case dataModifyingFailed(task: BanubaUtilities.SessionDataTask)
    case noURLResponse(task: BanubaUtilities.SessionDataTask)
    case cancelledByDelegate(response: Foundation.URLResponse)
  }
  public enum CacheErrorReason {
    case fileEnumeratorCreationFailed(url: Foundation.URL)
    case invalidFileEnumeratorContent(url: Foundation.URL)
    case invalidURLResource(error: any Swift.Error, key: Swift.String, url: Foundation.URL)
    case cannotLoadDataFromDisk(url: Foundation.URL, error: any Swift.Error)
    case cannotCreateDirectory(path: Swift.String, error: any Swift.Error)
    case imageNotExisting(key: Swift.String)
    case cannotConvertToData(object: Any, error: any Swift.Error)
    case cannotSerializeImage(image: BanubaUtilities.KFCrossPlatformImage?, original: Foundation.Data?, serializer: any BanubaUtilities.CacheSerializer)
    case cannotCreateCacheFile(fileURL: Foundation.URL, key: Swift.String, data: Foundation.Data, error: any Swift.Error)
    case cannotSetCacheFileAttribute(filePath: Swift.String, attributes: [Foundation.FileAttributeKey : Any], error: any Swift.Error)
    case diskStorageIsNotReady(cacheURL: Foundation.URL)
  }
  public enum ProcessorErrorReason {
    case processingFailed(processor: any BanubaUtilities.ImageProcessor, item: BanubaUtilities.ImageProcessItem)
  }
  public enum ImageSettingErrorReason {
    case emptySource
    case notCurrentSourceTask(result: BanubaUtilities.RetrieveImageResult?, error: (any Swift.Error)?, source: BanubaUtilities.Source)
    case dataProviderError(provider: any BanubaUtilities.ImageDataProvider, error: any Swift.Error)
    case alternativeSourcesExhausted([BanubaUtilities.PropagationError])
  }
  case requestError(reason: BanubaUtilities.KingfisherError.RequestErrorReason)
  case responseError(reason: BanubaUtilities.KingfisherError.ResponseErrorReason)
  case cacheError(reason: BanubaUtilities.KingfisherError.CacheErrorReason)
  case processorError(reason: BanubaUtilities.KingfisherError.ProcessorErrorReason)
  case imageSettingError(reason: BanubaUtilities.KingfisherError.ImageSettingErrorReason)
  public var isTaskCancelled: Swift.Bool {
    get
  }
  public func isInvalidResponseStatusCode(_ code: Swift.Int) -> Swift.Bool
  public var isInvalidResponseStatusCode: Swift.Bool {
    get
  }
  public var isNotCurrentTask: Swift.Bool {
    get
  }
}
extension BanubaUtilities.KingfisherError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension BanubaUtilities.KingfisherError : Foundation.CustomNSError {
  public static let domain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
}
public protocol AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  var onDownloadTaskStarted: ((BanubaUtilities.DownloadTask?) -> Swift.Void)? { get }
}
public protocol ImageDownloadRequestModifier : BanubaUtilities.AsyncImageDownloadRequestModifier {
  func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
}
extension BanubaUtilities.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest, reportModified: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public var onDownloadTaskStarted: ((BanubaUtilities.DownloadTask?) -> Swift.Void)? {
    get
  }
}
public struct AnyModifier : BanubaUtilities.ImageDownloadRequestModifier {
  public func modified(for request: Foundation.URLRequest) -> Foundation.URLRequest?
  public init(modify: @escaping (Foundation.URLRequest) -> Foundation.URLRequest?)
}
public struct AudioContext {
  public static let averagePeak: Swift.Float
  public static func averagePowers(audioFileURL: Foundation.URL, forChannel channelNumber: Swift.Int, compositionStart: Foundation.TimeInterval, compositionEnd: Foundation.TimeInterval?, duration: Foundation.TimeInterval, numberOfPeaks: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int) -> [Swift.Float]
  public static func amplitudeSamples(audioFileURL: Foundation.URL, numberOfSamples: Swift.Int, completionHandler: @escaping (_ success: [Swift.Float]) -> ())
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func withLatestFrom<Other, Result>(_ other: Other, resultSelector: @escaping (Self.Output, Other.Output) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Other, Result> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1, Result>(_ other: Other, _ other1: Other1, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2, Result>(_ other: Other, _ other1: Other1, _ other2: Other2, resultSelector: @escaping (Self.Output, (Other.Output, Other1.Output, Other2.Output)) -> Result) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, Result> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
  public func withLatestFrom<Other>(_ other: Other) -> Combine.Publishers.WithLatestFrom<Self, Other, Other.Output> where Other : Combine.Publisher, Self.Failure == Other.Failure
  public func withLatestFrom<Other, Other1>(_ other: Other, _ other1: Other1) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output), Self.Failure>, (Other.Output, Other1.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure
  public func withLatestFrom<Other, Other1, Other2>(_ other: Other, _ other1: Other1, _ other2: Other2) -> Combine.Publishers.WithLatestFrom<Self, Combine.AnyPublisher<(Other.Output, Other1.Output, Other2.Output), Self.Failure>, (Other.Output, Other1.Output, Other2.Output)> where Other : Combine.Publisher, Other1 : Combine.Publisher, Other2 : Combine.Publisher, Self.Failure == Other.Failure, Other.Failure == Other1.Failure, Other1.Failure == Other2.Failure
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct WithLatestFrom<Upstream, Other, Output> : Combine.Publisher where Upstream : Combine.Publisher, Other : Combine.Publisher, Upstream.Failure == Other.Failure {
    public typealias Failure = Upstream.Failure
    public typealias ResultSelector = (Upstream.Output, Other.Output) -> Output
    public func receive<S>(subscriber: S) where Output == S.Input, S : Combine.Subscriber, Other.Failure == S.Failure
  }
}
@objc public class TextButtonConfiguration : ObjectiveC.NSObject {
  public var style: BanubaUtilities.TextConfiguration
  public var text: Swift.String?
  public init(style: BanubaUtilities.TextConfiguration, text: Swift.String? = nil)
  @objc deinit
}
public enum AspectRatio : Swift.UInt8, Swift.Codable {
  case original
  case aspect16x9
  case aspect9x16
  case aspect4x3
  case aspect4x5
  public func getVideoAspectRatio(withVideoSize videoSize: CoreFoundation.CGSize? = nil) -> CoreFoundation.CGFloat
  public init(videoAspectRatio: CoreFoundation.CGFloat)
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension CoreFoundation.CGRect {
  public func getCenter() -> CoreFoundation.CGPoint
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class SlideInPresentationManager : ObjectiveC.NSObject, UIKit.UIViewControllerTransitioningDelegate {
  @_Concurrency.MainActor(unsafe) public var backgroundViewInteractionHandler: (() -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public init(coverPercentage: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: BanubaUtilities.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool = false, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor(unsafe) public init(coverHeight: CoreFoundation.CGFloat, panToDismiss: Swift.Bool, backgroundViewStyle: BanubaUtilities.BackgroundViewStyle, dismissOnTapByBackgroundView: Swift.Bool, transitionDuration: Foundation.TimeInterval = 0.3)
  @_Concurrency.MainActor(unsafe) @objc convenience override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc public func presentationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController?, source: UIKit.UIViewController) -> UIKit.UIPresentationController?
  @_Concurrency.MainActor(unsafe) @objc public func animationController(forPresented presented: UIKit.UIViewController, presenting: UIKit.UIViewController, source: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func animationController(forDismissed dismissed: UIKit.UIViewController) -> (any UIKit.UIViewControllerAnimatedTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func interactionControllerForPresentation(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @_Concurrency.MainActor(unsafe) @objc public func interactionControllerForDismissal(using animator: any UIKit.UIViewControllerAnimatedTransitioning) -> (any UIKit.UIViewControllerInteractiveTransitioning)?
  @objc deinit
}
public typealias DownloadProgressBlock = ((_ receivedSize: Swift.Int64, _ totalSize: Swift.Int64) -> Swift.Void)
public struct RetrieveImageResult {
  public let image: BanubaUtilities.KFCrossPlatformImage
  public let cacheType: BanubaUtilities.CacheType
  public let source: BanubaUtilities.Source
  public let originalSource: BanubaUtilities.Source
  public let data: () -> Foundation.Data?
}
public struct PropagationError {
  public let source: BanubaUtilities.Source
  public let error: BanubaUtilities.KingfisherError
}
public typealias DownloadTaskUpdatedBlock = ((_ newTask: BanubaUtilities.DownloadTask?) -> Swift.Void)
public class KingfisherManager {
  public static let shared: BanubaUtilities.KingfisherManager
  public var cache: BanubaUtilities.ImageCache
  public var downloader: BanubaUtilities.ImageDownloader
  public var defaultOptions: BanubaUtilities.KingfisherOptionsInfo
  public init(downloader: BanubaUtilities.ImageDownloader, cache: BanubaUtilities.ImageCache)
  @discardableResult
  public func retrieveImage(with resource: any BanubaUtilities.Resource, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, downloadTaskUpdated: BanubaUtilities.DownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func retrieveImage(with source: BanubaUtilities.Source, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, downloadTaskUpdated: BanubaUtilities.DownloadTaskUpdatedBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?) -> BanubaUtilities.DownloadTask?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class BaseTrackSelectionViewController : UIKit.UINavigationController, BanubaUtilities.TrackSelectionViewController {
  @_Concurrency.MainActor(unsafe) weak public var trackSelectionDelegate: (any BanubaUtilities.TrackSelectionViewControllerDelegate)?
  @available(iOS 5.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public protocol TrackSelectionViewControllerDelegate : AnyObject {
  func trackSelectionViewController(viewController: any BanubaUtilities.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL?, timeRange: CoreMedia.CMTimeRange?, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func trackSelectionViewControllerDidCancel(viewController: any BanubaUtilities.TrackSelectionViewController)
  func trackSelectionViewControllerDiscardCurrentTrack(viewController: any BanubaUtilities.TrackSelectionViewController)
}
extension BanubaUtilities.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewController(viewController: any BanubaUtilities.TrackSelectionViewController, didSelectFile url: Foundation.URL, coverURL: Foundation.URL? = nil, timeRange: CoreMedia.CMTimeRange? = nil, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
}
extension BanubaUtilities.TrackSelectionViewControllerDelegate {
  public func trackSelectionViewControllerDiscardCurrentTrack(viewController: any BanubaUtilities.TrackSelectionViewController)
}
public protocol TrackSelectionViewController : UIKit.UIViewController {
  var trackSelectionDelegate: (any BanubaUtilities.TrackSelectionViewControllerDelegate)? { get set }
}
public class Delegate<Input, Output> {
  public init()
  public func delegate<T>(on target: T, block: ((T, Input) -> Output)?) where T : AnyObject
  public func call(_ input: Input) -> Output?
  public func callAsFunction(_ input: Input) -> Output?
  @objc deinit
}
extension BanubaUtilities.Delegate where Input == () {
  public func call() -> Output?
  public func callAsFunction() -> Output?
}
extension BanubaUtilities.Delegate where Input == (), Output : BanubaUtilities.OptionalProtocol {
  public func call() -> Output
  public func callAsFunction() -> Output
}
extension BanubaUtilities.Delegate where Output : BanubaUtilities.OptionalProtocol {
  public func call(_ input: Input) -> Output
  public func callAsFunction(_ input: Input) -> Output
}
public protocol OptionalProtocol {
  static var _createNil: Self { get }
}
extension Swift.Optional : BanubaUtilities.OptionalProtocol {
  public static var _createNil: Swift.Optional<Wrapped> {
    get
  }
}
public enum Connection : Swift.CustomStringConvertible {
  case none, wifi, cellular
  public var description: Swift.String {
    get
  }
  public static func == (a: BanubaUtilities.Connection, b: BanubaUtilities.Connection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AlertViewControllerFactory : AnyObject {
  func getAlertViewController() -> BanubaUtilities.AlertViewController?
  func getPopoverAlertViewController() -> BanubaUtilities.PopoverAlertViewController?
}
extension BanubaUtilities.AlertViewControllerFactory where Self : UIKit.UIViewController {
  public func getPopoverAlertViewController() -> BanubaUtilities.PopoverAlertViewController?
}
public protocol AlertPresentable : BanubaUtilities.AlertViewControllerFactory {
  func presentAlertViewController(alertType: BanubaUtilities.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String?, disagreeButtonTitle: Swift.String?, animated: Swift.Bool, completion: @escaping ((_ success: Swift.Bool, _ buttonType: BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void))
  func presentPopoverAlert(position: BanubaUtilities.OverlayPopoverActionsPosition, actions: [BanubaUtilities.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((BanubaUtilities.PopoverAlertViewController.ActionType) -> Swift.Void))
}
extension BanubaUtilities.AlertPresentable where Self : UIKit.UIViewController {
  public func presentAlertViewController(alertType: BanubaUtilities.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(title: Swift.String, message: Swift.String?, animated: Swift.Bool, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentAlert(alertType: BanubaUtilities.AlertViewController.AlertType, title: Swift.String, message: Swift.String?, animated: Swift.Bool = false, completion: ((Swift.Bool, BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void)?)
  public func presentSelectionAlert(withTitle title: Swift.String, message: Swift.String?, agreeButtonTitle: Swift.String? = nil, disagreeButtonTitle: Swift.String? = nil, animated: Swift.Bool = false, completion: @escaping ((_ success: Swift.Bool, _ buttonType: BanubaUtilities.AlertViewController.ButtonType?) -> Swift.Void))
  public func presentPopoverAlert(position: BanubaUtilities.OverlayPopoverActionsPosition, actions: [BanubaUtilities.PopoverAlertViewController.ActionType], animated: Swift.Bool, completion: @escaping ((BanubaUtilities.PopoverAlertViewController.ActionType) -> Swift.Void))
}
public enum SharedLocalizedStrings {
  public enum Errors {
    public static let noInternetConnection: Swift.String
  }
  public enum Common {
    public static let ok: Swift.String
    public static let yes: Swift.String
    public static let no: Swift.String
  }
  public enum Alert {
    public static let settings: Swift.String
    public static let refuseSettings: Swift.String
  }
  public enum Gallery {
    public static let damagedFile: Swift.String
    public static let exportVideoFailed: Swift.String
  }
  public enum AutoCut {
  }
}
extension Combine.Publisher {
  public func map<T>(to value: T) -> Combine.Publishers.Map<Self, T>
  public func convertToResult() -> Combine.AnyPublisher<Swift.Result<Self.Output, Self.Failure>, Swift.Never>
  public func mapSuccess<T, U, E>(_ transform: @escaping (T) -> Swift.Result<U, any Swift.Error>) -> Combine.Publishers.Map<Self, Swift.Result<U, any Swift.Error>> where E : Swift.Error, Self.Failure == Swift.Never, Self.Output == Swift.Result<T, E>
}
extension Combine.AnyPublisher {
  public static func just(_ output: Output) -> Combine.AnyPublisher<Output, Failure>
}
extension Dispatch.DispatchQueue.SchedulerTimeType.Stride {
  public static var searchFieldDebouncingTime: Dispatch.DispatchQueue.SchedulerTimeType.Stride {
    get
  }
}
@_hasMissingDesignatedInitializers public class VideoDurationFormatter {
  public static func format(_ timeInterval: Foundation.TimeInterval) -> Swift.String
  @objc deinit
}
extension UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: any BanubaUtilities.ImageTextButtonConfigurationProtocol)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: any BanubaUtilities.ImageButtonConfigurationProtocol)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: BanubaUtilities.BackButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: BanubaUtilities.RoundedButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: BanubaUtilities.RoundedButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: BanubaUtilities.SaveButtonConfiguration)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: BanubaUtilities.TextButtonConfiguration, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: BanubaUtilities.TextConfiguration?, with title: Swift.String)
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: (any BanubaUtilities.ImageConfigurationProtocol)?, forState controlState: UIKit.UIControl.State)
}
public protocol Placeholder {
  func add(to imageView: BanubaUtilities.KFCrossPlatformImageView)
  func remove(from imageView: BanubaUtilities.KFCrossPlatformImageView)
}
extension UIKit.UIImage : BanubaUtilities.Placeholder {
  public func add(to imageView: BanubaUtilities.KFCrossPlatformImageView)
  public func remove(from imageView: BanubaUtilities.KFCrossPlatformImageView)
}
extension BanubaUtilities.Placeholder where Self : UIKit.UIView {
  public func add(to imageView: BanubaUtilities.KFCrossPlatformImageView)
  public func remove(from imageView: BanubaUtilities.KFCrossPlatformImageView)
}
public protocol KFOptionSetter {
  var options: BanubaUtilities.KingfisherParsedOptionsInfo { get nonmutating set }
  var onFailureDelegate: BanubaUtilities.Delegate<BanubaUtilities.KingfisherError, Swift.Void> { get }
  var onSuccessDelegate: BanubaUtilities.Delegate<BanubaUtilities.RetrieveImageResult, Swift.Void> { get }
  var onProgressDelegate: BanubaUtilities.Delegate<(Swift.Int64, Swift.Int64), Swift.Void> { get }
  var delegateObserver: Swift.AnyObject { get }
}
extension BanubaUtilities.KF.Builder : BanubaUtilities.KFOptionSetter {
  public var delegateObserver: Swift.AnyObject {
    get
  }
}
extension BanubaUtilities.KFOptionSetter {
  public func onProgress(_ block: BanubaUtilities.DownloadProgressBlock?) -> Self
  public func onSuccess(_ block: ((BanubaUtilities.RetrieveImageResult) -> Swift.Void)?) -> Self
  public func onFailure(_ block: ((BanubaUtilities.KingfisherError) -> Swift.Void)?) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  public func targetCache(_ cache: BanubaUtilities.ImageCache) -> Self
  public func originalCache(_ cache: BanubaUtilities.ImageCache) -> Self
  public func downloader(_ downloader: BanubaUtilities.ImageDownloader) -> Self
  public func downloadPriority(_ priority: Swift.Float) -> Self
  public func forceRefresh(_ enabled: Swift.Bool = true) -> Self
  public func fromMemoryCacheOrRefresh(_ enabled: Swift.Bool = true) -> Self
  public func cacheMemoryOnly(_ enabled: Swift.Bool = true) -> Self
  public func waitForCache(_ enabled: Swift.Bool = true) -> Self
  public func onlyFromCache(_ enabled: Swift.Bool = true) -> Self
  public func backgroundDecode(_ enabled: Swift.Bool = true) -> Self
  public func callbackQueue(_ queue: BanubaUtilities.CallbackQueue) -> Self
  public func scaleFactor(_ factor: CoreFoundation.CGFloat) -> Self
  public func cacheOriginalImage(_ enabled: Swift.Bool = true) -> Self
  public func diskStoreWriteOptions(_ writingOptions: Foundation.Data.WritingOptions) -> Self
  public func loadDiskFileSynchronously(_ enabled: Swift.Bool = true) -> Self
  public func processingQueue(_ queue: BanubaUtilities.CallbackQueue?) -> Self
  public func alternativeSources(_ sources: [BanubaUtilities.Source]?) -> Self
  public func retry(_ strategy: (any BanubaUtilities.RetryStrategy)?) -> Self
  public func retry(maxCount: Swift.Int, interval: BanubaUtilities.DelayRetryStrategy.Interval = .seconds(3)) -> Self
  public func lowDataModeSource(_ source: BanubaUtilities.Source?) -> Self
  public func forceTransition(_ enabled: Swift.Bool = true) -> Self
  public func onFailureImage(_ image: BanubaUtilities.KFCrossPlatformImage?) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  public func requestModifier(_ modifier: any BanubaUtilities.AsyncImageDownloadRequestModifier) -> Self
  public func requestModifier(_ modifyBlock: @escaping (inout Foundation.URLRequest) -> Swift.Void) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  public func redirectHandler(_ handler: any BanubaUtilities.ImageDownloadRedirectHandler) -> Self
  public func redirectHandler(_ block: @escaping (BanubaUtilities.KF.RedirectPayload) -> Swift.Void) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  public func setProcessor(_ processor: any BanubaUtilities.ImageProcessor) -> Self
  public func setProcessors(_ processors: [any BanubaUtilities.ImageProcessor]) -> Self
  public func appendProcessor(_ processor: any BanubaUtilities.ImageProcessor) -> Self
  public func roundCorner(radius: BanubaUtilities.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> Self
  public func blur(radius: CoreFoundation.CGFloat) -> Self
  public func overlay(color: BanubaUtilities.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5) -> Self
  public func tint(color: BanubaUtilities.KFCrossPlatformColor) -> Self
  public func blackWhite() -> Self
  public func cropping(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = .init(x: 0.5, y: 0.5)) -> Self
  public func downsampling(size: CoreFoundation.CGSize) -> Self
  public func resizing(referenceSize: CoreFoundation.CGSize, mode: BanubaUtilities.ContentMode = .none) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  public func serialize(by cacheSerializer: any BanubaUtilities.CacheSerializer) -> Self
  public func serialize(as format: BanubaUtilities.ImageFormat, jpegCompressionQuality: CoreFoundation.CGFloat? = nil) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  public func imageModifier(_ modifier: (any BanubaUtilities.ImageModifier)?) -> Self
  public func imageModifier(_ block: @escaping (inout BanubaUtilities.KFCrossPlatformImage) throws -> Swift.Void) -> Self
}
extension BanubaUtilities.KFOptionSetter {
  public func memoryCacheExpiration(_ expiration: BanubaUtilities.StorageExpiration?) -> Self
  public func memoryCacheAccessExtending(_ extending: BanubaUtilities.ExpirationExtending) -> Self
  public func diskCacheExpiration(_ expiration: BanubaUtilities.StorageExpiration?) -> Self
  public func diskCacheAccessExtending(_ extending: BanubaUtilities.ExpirationExtending) -> Self
}
public typealias PrefetcherProgressBlock = ((_ skippedResources: [any BanubaUtilities.Resource], _ failedResources: [any BanubaUtilities.Resource], _ completedResources: [any BanubaUtilities.Resource]) -> Swift.Void)
public typealias PrefetcherSourceProgressBlock = ((_ skippedSources: [BanubaUtilities.Source], _ failedSources: [BanubaUtilities.Source], _ completedSources: [BanubaUtilities.Source]) -> Swift.Void)
public typealias PrefetcherCompletionHandler = ((_ skippedResources: [any BanubaUtilities.Resource], _ failedResources: [any BanubaUtilities.Resource], _ completedResources: [any BanubaUtilities.Resource]) -> Swift.Void)
public typealias PrefetcherSourceCompletionHandler = ((_ skippedSources: [BanubaUtilities.Source], _ failedSources: [BanubaUtilities.Source], _ completedSources: [BanubaUtilities.Source]) -> Swift.Void)
@_hasMissingDesignatedInitializers public class ImagePrefetcher : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var maxConcurrentDownloads: Swift.Int
  convenience public init(urls: [Foundation.URL], options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.PrefetcherProgressBlock? = nil, completionHandler: BanubaUtilities.PrefetcherCompletionHandler? = nil)
  convenience public init(urls: [Foundation.URL], options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: BanubaUtilities.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any BanubaUtilities.Resource], options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.PrefetcherProgressBlock? = nil, completionHandler: BanubaUtilities.PrefetcherCompletionHandler? = nil)
  convenience public init(resources: [any BanubaUtilities.Resource], options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: BanubaUtilities.PrefetcherCompletionHandler? = nil)
  convenience public init(sources: [BanubaUtilities.Source], options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.PrefetcherSourceProgressBlock? = nil, completionHandler: BanubaUtilities.PrefetcherSourceCompletionHandler? = nil)
  convenience public init(sources: [BanubaUtilities.Source], options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: BanubaUtilities.PrefetcherSourceCompletionHandler? = nil)
  public func start()
  public func stop()
  @objc deinit
}
@objc public class BackgroundConfiguration : ObjectiveC.NSObject {
  public var cornerRadius: CoreFoundation.CGFloat
  public var color: UIKit.UIColor
  public init(cornerRadius: CoreFoundation.CGFloat, color: UIKit.UIColor)
  @objc deinit
}
public enum ImageProcessItem {
  case image(BanubaUtilities.KFCrossPlatformImage)
  case data(Foundation.Data)
}
public protocol ImageProcessor {
  var identifier: Swift.String { get }
  func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
extension BanubaUtilities.ImageProcessor {
  public func append(another: any BanubaUtilities.ImageProcessor) -> any BanubaUtilities.ImageProcessor
}
public struct DefaultImageProcessor : BanubaUtilities.ImageProcessor {
  public static let `default`: BanubaUtilities.DefaultImageProcessor
  public let identifier: Swift.String
  public init()
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct RectCorner : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let topLeft: BanubaUtilities.RectCorner
  public static let topRight: BanubaUtilities.RectCorner
  public static let bottomLeft: BanubaUtilities.RectCorner
  public static let bottomRight: BanubaUtilities.RectCorner
  public static let all: BanubaUtilities.RectCorner
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = BanubaUtilities.RectCorner
  public typealias Element = BanubaUtilities.RectCorner
  public typealias RawValue = Swift.Int
}
public struct BlendImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let blendMode: CoreGraphics.CGBlendMode
  public let alpha: CoreFoundation.CGFloat
  public let backgroundColor: BanubaUtilities.KFCrossPlatformColor?
  public init(blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public enum Radius {
  case widthFraction(CoreFoundation.CGFloat)
  case heightFraction(CoreFoundation.CGFloat)
  case point(CoreFoundation.CGFloat)
  public func compute(with size: CoreFoundation.CGSize) -> CoreFoundation.CGFloat
}
public struct RoundCornerImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let radius: BanubaUtilities.Radius
  public let roundingCorners: BanubaUtilities.RectCorner
  public let targetSize: CoreFoundation.CGSize?
  public let backgroundColor: BanubaUtilities.KFCrossPlatformColor?
  public init(cornerRadius: CoreFoundation.CGFloat, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil)
  public init(radius: BanubaUtilities.Radius, targetSize: CoreFoundation.CGSize? = nil, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct Border {
  public var color: BanubaUtilities.KFCrossPlatformColor
  public var lineWidth: CoreFoundation.CGFloat
  public var radius: BanubaUtilities.Radius
  public var roundingCorners: BanubaUtilities.RectCorner
  public init(color: BanubaUtilities.KFCrossPlatformColor = .black, lineWidth: CoreFoundation.CGFloat = 4, radius: BanubaUtilities.Radius = .point(0), roundingCorners: BanubaUtilities.RectCorner = .all)
}
public struct BorderImageProcessor : BanubaUtilities.ImageProcessor {
  public var identifier: Swift.String {
    get
  }
  public let border: BanubaUtilities.Border
  public init(border: BanubaUtilities.Border)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public enum ContentMode {
  case none
  case aspectFit
  case aspectFill
  public static func == (a: BanubaUtilities.ContentMode, b: BanubaUtilities.ContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ResizingImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let referenceSize: CoreFoundation.CGSize
  public let targetContentMode: BanubaUtilities.ContentMode
  public init(referenceSize: CoreFoundation.CGSize, mode: BanubaUtilities.ContentMode = .none)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct BlurImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let blurRadius: CoreFoundation.CGFloat
  public init(blurRadius: CoreFoundation.CGFloat)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct OverlayImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let overlay: BanubaUtilities.KFCrossPlatformColor
  public let fraction: CoreFoundation.CGFloat
  public init(overlay: BanubaUtilities.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat = 0.5)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct TintImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let tint: BanubaUtilities.KFCrossPlatformColor
  public init(tint: BanubaUtilities.KFCrossPlatformColor)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct ColorControlsProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let brightness: CoreFoundation.CGFloat
  public let contrast: CoreFoundation.CGFloat
  public let saturation: CoreFoundation.CGFloat
  public let inputEV: CoreFoundation.CGFloat
  public init(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct BlackWhiteProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public init()
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct CroppingImageProcessor : BanubaUtilities.ImageProcessor {
  public let identifier: Swift.String
  public let size: CoreFoundation.CGSize
  public let anchor: CoreFoundation.CGPoint
  public init(size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5))
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct DownsamplingImageProcessor : BanubaUtilities.ImageProcessor {
  public let size: CoreFoundation.CGSize
  public let identifier: Swift.String
  public init(size: CoreFoundation.CGSize)
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
infix operator |> : AdditionPrecedence
public func |> (left: any BanubaUtilities.ImageProcessor, right: any BanubaUtilities.ImageProcessor) -> any BanubaUtilities.ImageProcessor
public struct BlurCoordinateParams : Swift.Codable {
  public var center: CoreFoundation.CGPoint
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var radius: CoreFoundation.CGFloat
  public var absoluteCenter: CoreFoundation.CGPoint
  public var absoluteRadius: CoreFoundation.CGFloat
  public static var zero: BanubaUtilities.BlurCoordinateParams {
    get
  }
  public init(center: CoreFoundation.CGPoint, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, radius: CoreFoundation.CGFloat)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum GalleryError : Foundation.CustomNSError, Foundation.LocalizedError {
  case uploadingFailed
  case error(any Swift.Error)
  case uploadingCancelled
  public var isCancelled: Swift.Bool {
    get
  }
  public static var errorDomain: Swift.String
  public var errorDescription: Swift.String? {
    get
  }
}
extension AVFoundation.AVAssetTrack {
  public var fixedPreferredTransform: CoreFoundation.CGAffineTransform {
    get
  }
}
extension UIKit.UIColor {
  convenience public init(red: Swift.Int, green: Swift.Int, blue: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
  convenience public init(rgb: Swift.Int, a: CoreFoundation.CGFloat = 1.0)
}
public protocol ImageDataProvider {
  var cacheKey: Swift.String { get }
  func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  var contentURL: Foundation.URL? { get }
}
extension BanubaUtilities.ImageDataProvider {
  public var contentURL: Foundation.URL? {
    get
  }
  public func convertToSource() -> BanubaUtilities.Source
}
public struct LocalFileImageDataProvider : BanubaUtilities.ImageDataProvider {
  public let fileURL: Foundation.URL
  public init(fileURL: Foundation.URL, cacheKey: Swift.String? = nil, loadingQueue: BanubaUtilities.ExecutionQueue = .dispatch(DispatchQueue.global(qos: .userInitiated)))
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
  #if compiler(>=5.3) && $EffectfulProp
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
  public var data: Foundation.Data {
    get async throws
  }
  #endif
  public var contentURL: Foundation.URL? {
    get
  }
}
public struct Base64ImageDataProvider : BanubaUtilities.ImageDataProvider {
  public let base64String: Swift.String
  public init(base64String: Swift.String, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
public struct RawImageDataProvider : BanubaUtilities.ImageDataProvider {
  public let data: Foundation.Data
  public init(data: Foundation.Data, cacheKey: Swift.String)
  public var cacheKey: Swift.String
  public func data(handler: @escaping (Swift.Result<Foundation.Data, any Swift.Error>) -> Swift.Void)
}
@_inheritsConvenienceInitializers @objc public class ZipArchive : ObjectiveC.NSObject {
  public static func zip(to destinationUrl: Foundation.URL, folderUrl: Foundation.URL) -> Swift.Bool
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) throws
  #if compiler(>=5.3) && $AsyncAwait
  @discardableResult
  public static func unzip(at sourceUrl: Foundation.URL, destination: Foundation.URL, overwrite: Swift.Bool) async throws -> Swift.String
  #endif
  @objc override dynamic public init()
  @objc deinit
}
public class BanubaCancelHandler {
  public init(handler: @escaping () -> Swift.Void)
  public func cancel()
  @objc deinit
}
public typealias Transformer = (CoreImage.CIImage) -> CoreImage.CIImage?
public protocol CIImageProcessor : BanubaUtilities.ImageProcessor {
  var filter: BanubaUtilities.Filter { get }
}
extension BanubaUtilities.CIImageProcessor {
  public func process(item: BanubaUtilities.ImageProcessItem, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct Filter {
  public init(transform: @escaping BanubaUtilities.Transformer)
  public static var tint: (_ color: BanubaUtilities.KFCrossPlatformColor) -> BanubaUtilities.Filter
  public typealias ColorElement = (CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat)
  public static var colorControl: (_ arg: BanubaUtilities.Filter.ColorElement) -> BanubaUtilities.Filter
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public func apply(_ filter: BanubaUtilities.Filter) -> BanubaUtilities.KFCrossPlatformImage
}
extension Swift.Double {
  public func formatted(isMiliSecondsEnabled: Swift.Bool = true) -> Swift.String
  public func stringFromTimeInterval() -> Swift.String
}
@objc public class GalleryConfiguration : ObjectiveC.NSObject {
  public var videoResolution: BanubaUtilities.VideoResolution
  public var galleryItemConfiguration: BanubaUtilities.GalleryItemConfiguration
  public var closeButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol
  public var albumButtonConfiguration: BanubaUtilities.TextButtonConfiguration
  public var albumArrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var collectionInfoHeaderConfiguration: BanubaUtilities.CollectionInfoHeaderConfiguration
  public var galleryItemPreviewViewConfiguration: BanubaUtilities.GalleryItemPreviewViewConfiguration
  public var nextButtonConfiguration: BanubaUtilities.SaveButtonConfiguration
  public var noItemsLabelConfiguration: BanubaUtilities.TextConfiguration
  public var layoutConfiguration: BanubaUtilities.GalleryLayoutConfiguration
  public var topBarBlurColor: UIKit.UIColor
  public var clearSelectionButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol
  public var galleryTypeButton: BanubaUtilities.TextButtonConfiguration
  public var galleryTypeUnderlineColor: UIKit.UIColor
  public var isPhotoSequenceAnimationEnabled: Swift.Bool
  public var importItemsLabelConfiguration: BanubaUtilities.TextConfiguration
  public var bottomViewConfiguration: BanubaUtilities.BackgroundConfiguration
  public var visibleTabsInGallery: [BanubaUtilities.GalleryMediaType]
  public var isCloseButtonHidden: Swift.Bool
  public var backgroundColor: UIKit.UIColor
  public var maximumSelectedCountFromGallery: Swift.Int
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public var alertConfiguration: BanubaUtilities.AlertViewConfiguration
  public var autoCutGalleryConfiguration: BanubaUtilities.AutoCutGalleryConfiguration?
  public init(videoResolution: BanubaUtilities.VideoResolution, galleryItemConfiguration: BanubaUtilities.GalleryItemConfiguration, closeButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol, albumButtonConfiguration: BanubaUtilities.TextButtonConfiguration, albumArrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol, collectionInfoHeaderConfiguration: BanubaUtilities.CollectionInfoHeaderConfiguration, galleryItemPreviewViewConfiguration: BanubaUtilities.GalleryItemPreviewViewConfiguration, nextButtonConfiguration: BanubaUtilities.SaveButtonConfiguration, noItemsLabelConfiguration: BanubaUtilities.TextConfiguration, layoutConfiguration: BanubaUtilities.GalleryLayoutConfiguration, topBarBlurColor: UIKit.UIColor, clearSelectionButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol, galleryTypeButton: BanubaUtilities.TextButtonConfiguration, galleryTypeUnderlineColor: UIKit.UIColor, isPhotoSequenceAnimationEnabled: Swift.Bool, importItemsLabelConfiguration: BanubaUtilities.TextConfiguration, bottomViewConfiguration: BanubaUtilities.BackgroundConfiguration, isCloseButtonHidden: Swift.Bool, visibleTabsInGallery: [BanubaUtilities.GalleryMediaType] = [.video, .photo], backgroundColor: UIKit.UIColor, maximumSelectedCountFromGallery: Swift.Int, preferredStatusBarStyle: UIKit.UIStatusBarStyle, alertConfiguration: BanubaUtilities.AlertViewConfiguration, autoCutGalleryConfiguration: BanubaUtilities.AutoCutGalleryConfiguration? = nil)
  @objc deinit
}
extension Foundation.NSNotification.Name {
  public static let KingfisherDidCleanDiskCache: Foundation.Notification.Name
}
public let KingfisherDiskCacheCleanedHashKey: Swift.String
public enum CacheType {
  case none
  case memory
  case disk
  public var cached: Swift.Bool {
    get
  }
  public static func == (a: BanubaUtilities.CacheType, b: BanubaUtilities.CacheType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CacheStoreResult {
  public let memoryCacheResult: Swift.Result<(), Swift.Never>
  public let diskCacheResult: Swift.Result<(), BanubaUtilities.KingfisherError>
}
extension UIKit.UIImage : BanubaUtilities.CacheCostCalculable {
  public var cacheCost: Swift.Int {
    get
  }
}
extension Foundation.Data : BanubaUtilities.DataTransformable {
  public func toData() throws -> Foundation.Data
  public static func fromData(_ data: Foundation.Data) throws -> Foundation.Data
  public static let empty: Foundation.Data
}
public enum ImageCacheResult {
  case disk(BanubaUtilities.KFCrossPlatformImage)
  case memory(BanubaUtilities.KFCrossPlatformImage)
  case none
  public var image: BanubaUtilities.KFCrossPlatformImage? {
    get
  }
  public var cacheType: BanubaUtilities.CacheType {
    get
  }
}
open class ImageCache {
  public static let `default`: BanubaUtilities.ImageCache
  final public let memoryStorage: BanubaUtilities.MemoryStorage.Backend<BanubaUtilities.KFCrossPlatformImage>
  final public let diskStorage: BanubaUtilities.DiskStorage.Backend<Foundation.Data>
  public typealias DiskCachePathClosure = (Foundation.URL, Swift.String) -> Foundation.URL
  public init(memoryStorage: BanubaUtilities.MemoryStorage.Backend<BanubaUtilities.KFCrossPlatformImage>, diskStorage: BanubaUtilities.DiskStorage.Backend<Foundation.Data>)
  convenience public init(name: Swift.String)
  convenience public init(name: Swift.String, cacheDirectoryURL: Foundation.URL?, diskCachePathClosure: BanubaUtilities.ImageCache.DiskCachePathClosure? = nil) throws
  @objc deinit
  open func store(_ image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo, toDisk: Swift.Bool = true, completionHandler: ((BanubaUtilities.CacheStoreResult) -> Swift.Void)? = nil)
  open func store(_ image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data? = nil, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", cacheSerializer serializer: any BanubaUtilities.CacheSerializer = DefaultCacheSerializer.default, toDisk: Swift.Bool = true, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: ((BanubaUtilities.CacheStoreResult) -> Swift.Void)? = nil)
  open func storeToDisk(_ data: Foundation.Data, forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", expiration: BanubaUtilities.StorageExpiration? = nil, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: ((BanubaUtilities.CacheStoreResult) -> Swift.Void)? = nil)
  open func removeImage(forKey key: Swift.String, processorIdentifier identifier: Swift.String = "", fromMemory: Swift.Bool = true, fromDisk: Swift.Bool = true, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: (() -> Swift.Void)? = nil)
  open func retrieveImage(forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo, callbackQueue: BanubaUtilities.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((Swift.Result<BanubaUtilities.ImageCacheResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?)
  open func retrieveImage(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil, callbackQueue: BanubaUtilities.CallbackQueue = .mainCurrentOrAsync, completionHandler: ((Swift.Result<BanubaUtilities.ImageCacheResult, BanubaUtilities.KingfisherError>) -> Swift.Void)?)
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
  open func retrieveImageInMemoryCache(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil) -> BanubaUtilities.KFCrossPlatformImage?
  open func retrieveImageInDiskCache(forKey key: Swift.String, options: BanubaUtilities.KingfisherOptionsInfo? = nil, callbackQueue: BanubaUtilities.CallbackQueue = .untouch, completionHandler: @escaping (Swift.Result<BanubaUtilities.KFCrossPlatformImage?, BanubaUtilities.KingfisherError>) -> Swift.Void)
  public func clearCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func clearMemoryCache()
  open func clearDiskCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredCache(completion handler: (() -> Swift.Void)? = nil)
  open func cleanExpiredMemoryCache()
  open func cleanExpiredDiskCache(completion handler: (() -> Swift.Void)? = nil)
  @objc public func backgroundCleanExpiredDiskCache()
  open func imageCachedType(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> BanubaUtilities.CacheType
  public func isCached(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.Bool
  open func hash(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
  open func calculateDiskStorageSize(completion handler: @escaping ((Swift.Result<Swift.UInt, BanubaUtilities.KingfisherError>) -> Swift.Void))
  #if compiler(>=5.3) && $EffectfulProp
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
  open var diskStorageSize: Swift.UInt {
    get async throws
  }
  #endif
  open func cachePath(forKey key: Swift.String, processorIdentifier identifier: Swift.String = DefaultImageProcessor.default.identifier) -> Swift.String
}
extension UIKit.UIApplication : BanubaUtilities.KingfisherCompatible {
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIApplication {
  public static var shared: UIKit.UIApplication? {
    get
  }
}
@objc public protocol TimeLineDataSourceDelegate {
  @objc optional func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource)
}
@objc public protocol TimeLineDataSource {
  @objc var delegate: (any BanubaUtilities.TimeLineDataSourceDelegate)? { get set }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var duration: CoreMedia.CMTime { get }
  @objc var thumbnails: [UIKit.UIImage] { get }
  @objc var isAllThumbnailsFetched: Swift.Bool { get }
  @objc var thumbnailsCount: Swift.Int { get }
  @objc var thumbnailHeight: CoreFoundation.CGFloat { get }
  @objc func loadPreview(completion: @escaping (UIKit.UIImage?) -> Swift.Void, at second: Swift.Double)
  @objc func getImage(at index: Swift.Int) -> UIKit.UIImage?
  @objc func loadTimelineThumbs(completion: (() -> Swift.Void)?)
}
public enum DiskStorage {
  @_hasMissingDesignatedInitializers public class Backend<T> where T : BanubaUtilities.DataTransformable {
    public var config: BanubaUtilities.DiskStorage.Config
    final public let directoryURL: Foundation.URL
    convenience public init(config: BanubaUtilities.DiskStorage.Config) throws
    public func store(value: T, forKey key: Swift.String, expiration: BanubaUtilities.StorageExpiration? = nil, writeOptions: Foundation.Data.WritingOptions = []) throws
    public func value(forKey key: Swift.String, extendingExpiration: BanubaUtilities.ExpirationExtending = .cacheTime) throws -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func isCached(forKey key: Swift.String, referenceDate: Foundation.Date) -> Swift.Bool
    public func remove(forKey key: Swift.String) throws
    public func removeAll() throws
    public func cacheFileURL(forKey key: Swift.String) -> Foundation.URL
    public func removeExpiredValues() throws -> [Foundation.URL]
    public func totalSize() throws -> Swift.UInt
    @objc deinit
  }
}
extension BanubaUtilities.DiskStorage {
  public struct Config {
    public var sizeLimit: Swift.UInt
    public var expiration: BanubaUtilities.StorageExpiration
    public var pathExtension: Swift.String?
    public var usesHashedFileName: Swift.Bool
    public var autoExtAfterHashedFileName: Swift.Bool
    public var cachePathBlock: ((_ directory: Foundation.URL, _ cacheName: Swift.String) -> Foundation.URL)!
    public init(name: Swift.String, sizeLimit: Swift.UInt, fileManager: Foundation.FileManager = .default, directory: Foundation.URL? = nil)
  }
}
@objc public protocol AlbumModel {
  @objc var name: Swift.String? { get set }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var assetCollection: Photos.PHAssetCollection { get }
}
@objc public class AlbumViewModel : ObjectiveC.NSObject, BanubaUtilities.AlbumModel {
  final public let model: BanubaUtilities.ItemCollectionModel
  @objc final public let assetCollection: Photos.PHAssetCollection
  @objc public var name: Swift.String?
  @objc public var preview: UIKit.UIImage?
  public var itemsCount: Swift.Int
  public init(collection: BanubaUtilities.ItemCollectionModel)
  public func requestPreview(handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc deinit
}
extension CoreFoundation.CGSize : BanubaUtilities.KingfisherCompatibleValue {
}
extension BanubaUtilities.KingfisherWrapper where Base == CoreFoundation.CGSize {
  public func resize(to size: CoreFoundation.CGSize, for contentMode: BanubaUtilities.ContentMode) -> CoreFoundation.CGSize
  public func constrained(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func filling(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func constrainedRect(for size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint) -> CoreFoundation.CGRect
}
public enum DeviceModel : Swift.String {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPhoneSE2
  case iPhone12
  case iPhone12Mini
  case iPhone12Pro
  case iPhone12ProMax
  case iPhone13
  case iPhone13Mini
  case iPhone13Pro
  case iPhone13ProMax
  case iPhoneSE3
  case iPhone14
  case iPhone14Plus
  case iPhone14Pro
  case iPhone14ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPad8
  case iPad9
  case iPad10
  case iPadAir4
  case iPadAir5
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadMini6
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case iPadPro11Inch2
  case iPadPro12Inch4
  case iPadPro11Inch3
  case iPadPro12Inch5
  case iPadPro11Inch4
  case iPadPro12Inch6
  case simulator
  case unknown
  public static var current: BanubaUtilities.DeviceModel {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> BanubaUtilities.DeviceModel
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct SaveButtonConfiguration {
  public var textConfiguration: BanubaUtilities.TextConfiguration
  public var inactiveTextConfiguration: BanubaUtilities.TextConfiguration
  public var text: Swift.String
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var inactiveBackgroundColor: UIKit.UIColor
  public init(textConfiguration: BanubaUtilities.TextConfiguration, inactiveTextConfiguration: BanubaUtilities.TextConfiguration, text: Swift.String, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, inactiveBackgroundColor: UIKit.UIColor)
}
extension Swift.String : BanubaUtilities.KingfisherCompatibleValue {
}
public enum Source {
  public enum Identifier {
    public typealias Value = Swift.UInt
  }
  case network(any BanubaUtilities.Resource)
  case provider(any BanubaUtilities.ImageDataProvider)
  public var cacheKey: Swift.String {
    get
  }
  public var url: Foundation.URL? {
    get
  }
}
extension BanubaUtilities.Source : Swift.Hashable {
  public static func == (lhs: BanubaUtilities.Source, rhs: BanubaUtilities.Source) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias KingfisherOptionsInfo = [BanubaUtilities.KingfisherOptionsInfoItem]
public enum KingfisherOptionsInfoItem {
  case targetCache(BanubaUtilities.ImageCache)
  case originalCache(BanubaUtilities.ImageCache)
  case downloader(BanubaUtilities.ImageDownloader)
  case transition(BanubaUtilities.ImageTransition)
  case downloadPriority(Swift.Float)
  case forceRefresh
  case fromMemoryCacheOrRefresh
  case forceTransition
  case cacheMemoryOnly
  case waitForCache
  case onlyFromCache
  case backgroundDecode
  case callbackQueue(BanubaUtilities.CallbackQueue)
  case scaleFactor(CoreFoundation.CGFloat)
  case preloadAllAnimationData
  case requestModifier(any BanubaUtilities.AsyncImageDownloadRequestModifier)
  case redirectHandler(any BanubaUtilities.ImageDownloadRedirectHandler)
  case processor(any BanubaUtilities.ImageProcessor)
  case cacheSerializer(any BanubaUtilities.CacheSerializer)
  case imageModifier(any BanubaUtilities.ImageModifier)
  case keepCurrentImageWhileLoading
  case onlyLoadFirstFrame
  case cacheOriginalImage
  case onFailureImage(BanubaUtilities.KFCrossPlatformImage?)
  case alsoPrefetchToMemory
  case loadDiskFileSynchronously
  case diskStoreWriteOptions(Foundation.Data.WritingOptions)
  case memoryCacheExpiration(BanubaUtilities.StorageExpiration)
  case memoryCacheAccessExtendingExpiration(BanubaUtilities.ExpirationExtending)
  case diskCacheExpiration(BanubaUtilities.StorageExpiration)
  case diskCacheAccessExtendingExpiration(BanubaUtilities.ExpirationExtending)
  case processingQueue(BanubaUtilities.CallbackQueue)
  case progressiveJPEG(BanubaUtilities.ImageProgressive)
  case alternativeSources([BanubaUtilities.Source])
  case retryStrategy(any BanubaUtilities.RetryStrategy)
  case lowDataMode(BanubaUtilities.Source?)
}
public struct KingfisherParsedOptionsInfo {
  public var targetCache: BanubaUtilities.ImageCache?
  public var originalCache: BanubaUtilities.ImageCache?
  public var downloader: BanubaUtilities.ImageDownloader?
  public var transition: BanubaUtilities.ImageTransition
  public var downloadPriority: Swift.Float
  public var forceRefresh: Swift.Bool
  public var fromMemoryCacheOrRefresh: Swift.Bool
  public var forceTransition: Swift.Bool
  public var cacheMemoryOnly: Swift.Bool
  public var waitForCache: Swift.Bool
  public var onlyFromCache: Swift.Bool
  public var backgroundDecode: Swift.Bool
  public var preloadAllAnimationData: Swift.Bool
  public var callbackQueue: BanubaUtilities.CallbackQueue
  public var scaleFactor: CoreFoundation.CGFloat
  public var requestModifier: (any BanubaUtilities.AsyncImageDownloadRequestModifier)?
  public var redirectHandler: (any BanubaUtilities.ImageDownloadRedirectHandler)?
  public var processor: any BanubaUtilities.ImageProcessor
  public var imageModifier: (any BanubaUtilities.ImageModifier)?
  public var cacheSerializer: any BanubaUtilities.CacheSerializer
  public var keepCurrentImageWhileLoading: Swift.Bool
  public var onlyLoadFirstFrame: Swift.Bool
  public var cacheOriginalImage: Swift.Bool
  public var onFailureImage: BanubaUtilities.KFCrossPlatformImage??
  public var alsoPrefetchToMemory: Swift.Bool
  public var loadDiskFileSynchronously: Swift.Bool
  public var diskStoreWriteOptions: Foundation.Data.WritingOptions
  public var memoryCacheExpiration: BanubaUtilities.StorageExpiration?
  public var memoryCacheAccessExtendingExpiration: BanubaUtilities.ExpirationExtending
  public var diskCacheExpiration: BanubaUtilities.StorageExpiration?
  public var diskCacheAccessExtendingExpiration: BanubaUtilities.ExpirationExtending
  public var processingQueue: BanubaUtilities.CallbackQueue?
  public var progressiveJPEG: BanubaUtilities.ImageProgressive?
  public var alternativeSources: [BanubaUtilities.Source]?
  public var retryStrategy: (any BanubaUtilities.RetryStrategy)?
  public var lowDataModeSource: BanubaUtilities.Source?
  public init(_ info: BanubaUtilities.KingfisherOptionsInfo?)
}
extension Swift.Encodable {
  public func toDictionary(_ encoder: Foundation.JSONEncoder = JSONEncoder()) throws -> [Swift.String : Any]
  public func toString() throws -> Swift.String
}
extension UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ configuration: BanubaUtilities.TextConfiguration, with text: Swift.String)
}
extension CoreFoundation.CGPoint {
  public mutating func transformToGradientSpace()
  public func oppositePoint() -> CoreFoundation.CGPoint
  public static func gradientPointForAngle(_ angle: CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
}
public enum ImageTransition {
  case none
  case fade(Foundation.TimeInterval)
  case flipFromLeft(Foundation.TimeInterval)
  case flipFromRight(Foundation.TimeInterval)
  case flipFromTop(Foundation.TimeInterval)
  case flipFromBottom(Foundation.TimeInterval)
  case custom(duration: Foundation.TimeInterval, options: UIKit.UIView.AnimationOptions, animations: ((UIKit.UIImageView, UIKit.UIImage) -> Swift.Void)?, completion: ((Swift.Bool) -> Swift.Void)?)
}
public protocol Resource {
  var cacheKey: Swift.String { get }
  var downloadURL: Foundation.URL { get }
}
extension BanubaUtilities.Resource {
  public func convertToSource(overrideCacheKey: Swift.String? = nil) -> BanubaUtilities.Source
}
public struct ImageResource : BanubaUtilities.Resource {
  public init(downloadURL: Foundation.URL, cacheKey: Swift.String? = nil)
  public let cacheKey: Swift.String
  public let downloadURL: Foundation.URL
}
extension Foundation.URL : BanubaUtilities.Resource {
  public var cacheKey: Swift.String {
    get
  }
  public var downloadURL: Foundation.URL {
    get
  }
}
extension Swift.String {
  public func lookUpForImage(in bundle: Foundation.Bundle) -> UIKit.UIImage?
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var spinCircleLayer: QuartzCore.CAShapeLayer
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var configuration: BanubaUtilities.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func startAnimating()
  @_Concurrency.MainActor(unsafe) public func stopAnimating()
  @objc deinit
}
public struct ImageProgressive {
  public enum UpdatingStrategy {
    case `default`
    case keepCurrent
    case replace(BanubaUtilities.KFCrossPlatformImage?)
  }
  @available(*, deprecated, renamed: "init()", message: "Getting a default `ImageProgressive` is deprecated due to its syntax symatic is not clear. Use `ImageProgressive.init` instead.")
  public static let `default`: BanubaUtilities.ImageProgressive
  public let onImageUpdated: BanubaUtilities.Delegate<BanubaUtilities.KFCrossPlatformImage, BanubaUtilities.ImageProgressive.UpdatingStrategy>
  public init()
  public init(isBlur: Swift.Bool, isFastestScan: Swift.Bool, scanInterval: Foundation.TimeInterval)
}
public protocol EffectSelectionViewControllerDelegate : AnyObject {
  func effectSelectionViewController(viewController: any BanubaUtilities.EffectSelectionViewController, didSelectFile url: Foundation.URL, isEditable: Swift.Bool, title: Swift.String, additionalTitle: Swift.String?, uuid: Foundation.UUID)
  func effectSelectionViewControllerDidCancel(viewController: any BanubaUtilities.EffectSelectionViewController)
}
public protocol EffectSelectionViewController : UIKit.UIViewController {
  var effectSelectionDelegate: (any BanubaUtilities.EffectSelectionViewControllerDelegate)? { get set }
}
@objc public class VideoTimeLineCollectionViewHandler : ObjectiveC.NSObject {
  final public let collectionView: UIKit.UICollectionView
  final public let timeLineDataSource: any BanubaUtilities.TimeLineDataSource
  final public let cornerRadius: CoreFoundation.CGFloat
  public init(collectionView: UIKit.UICollectionView, timeLineDataSource: any BanubaUtilities.TimeLineDataSource, cornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler {
  public func applyContentInset(appliedWidth: CoreFoundation.CGFloat, cursorOffset: CoreFoundation.CGFloat? = nil)
  public func applyContentOffset(_ offset: CoreFoundation.CGPoint)
  public func cellSize() -> CoreFoundation.CGSize
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler : BanubaUtilities.TimeLineDataSourceDelegate {
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didPreloadPreview preview: UIKit.UIImage)
  @objc dynamic public func timelineDataSource(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource, didLoadImage image: UIKit.UIImage, at index: Swift.Int)
  @objc dynamic public func timelineDataSourceDidFinishThumbnailFetch(_ timelineDataSource: any BanubaUtilities.TimeLineDataSource)
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
}
extension BanubaUtilities.VideoTimeLineCollectionViewHandler : UIKit.UICollectionViewDelegateFlowLayout {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, minimumLineSpacingForSectionAt section: Swift.Int) -> CoreFoundation.CGFloat
}
public protocol ImageDownloaderDelegate : AnyObject {
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, with dataTask: BanubaUtilities.SessionDataTask) -> Foundation.Data?
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload image: BanubaUtilities.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  func isValidStatusCode(_ code: Swift.Int, for downloader: BanubaUtilities.ImageDownloader) -> Swift.Bool
  func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
}
extension BanubaUtilities.ImageDownloaderDelegate {
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, willDownloadImageForURL url: Foundation.URL, with request: Foundation.URLRequest?)
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didFinishDownloadingImageForURL url: Foundation.URL, with response: Foundation.URLResponse?, error: (any Swift.Error)?)
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload image: BanubaUtilities.KFCrossPlatformImage, for url: Foundation.URL, with response: Foundation.URLResponse?)
  public func isValidStatusCode(_ code: Swift.Int, for downloader: BanubaUtilities.ImageDownloader) -> Swift.Bool
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, with task: BanubaUtilities.SessionDataTask) -> Foundation.Data?
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didDownload data: Foundation.Data, for url: Foundation.URL) -> Foundation.Data?
  public func imageDownloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
}
public struct ImageLoadingResult {
  public let image: BanubaUtilities.KFCrossPlatformImage
  public let url: Foundation.URL?
  public let originalData: Foundation.Data
}
public struct DownloadTask {
  public let sessionTask: BanubaUtilities.SessionDataTask
  public let cancelToken: BanubaUtilities.SessionDataTask.CancelToken
  public func cancel()
}
open class ImageDownloader {
  public static let `default`: BanubaUtilities.ImageDownloader
  open var downloadTimeout: Swift.Double
  open var trustedHosts: Swift.Set<Swift.String>?
  open var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
    set
  }
  open var sessionDelegate: BanubaUtilities.SessionDelegate {
    get
    set
  }
  open var requestsUsePipelining: Swift.Bool
  weak open var delegate: (any BanubaUtilities.ImageDownloaderDelegate)?
  weak open var authenticationChallengeResponder: (any BanubaUtilities.AuthenticationChallengeResponsible)?
  public init(name: Swift.String)
  @objc deinit
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherParsedOptionsInfo, completionHandler: ((Swift.Result<BanubaUtilities.ImageLoadingResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.ImageLoadingResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  open func downloadImage(with url: Foundation.URL, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<BanubaUtilities.ImageLoadingResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
}
extension BanubaUtilities.ImageDownloader {
  public func cancelAll()
  public func cancel(url: Foundation.URL)
}
extension BanubaUtilities.ImageDownloader : BanubaUtilities.AuthenticationChallengeResponsible {
}
extension BanubaUtilities.ImageDownloader : BanubaUtilities.ImageDownloaderDelegate {
}
@_hasMissingDesignatedInitializers public class ConnectionListener {
  final public let onConnectionChanged: ((BanubaUtilities.Connection) -> ())
  @objc deinit
}
public protocol ReachabilityServicing {
  var currentConnection: BanubaUtilities.Connection { get }
  var isInternetAvailable: Swift.Bool { get }
  func listenConnection(onConnectionChanged: @escaping ((BanubaUtilities.Connection) -> ())) -> BanubaUtilities.ConnectionListener
  func stopListenConnection(for connectionListener: BanubaUtilities.ConnectionListener)
}
public struct ReachabilityServiceBuilder {
  public static func build() -> (any BanubaUtilities.ReachabilityServicing)?
}
public enum StorageExpiration {
  case never
  case seconds(Foundation.TimeInterval)
  case days(Swift.Int)
  case date(Foundation.Date)
  case expired
}
public enum ExpirationExtending {
  case none
  case cacheTime
  case expirationTime(_: BanubaUtilities.StorageExpiration)
}
public protocol CacheCostCalculable {
  var cacheCost: Swift.Int { get }
}
public protocol DataTransformable {
  func toData() throws -> Foundation.Data
  static func fromData(_ data: Foundation.Data) throws -> Self
  static var empty: Self { get }
}
public protocol ImageModifier {
  func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct AnyImageModifier : BanubaUtilities.ImageModifier {
  public init(modify: @escaping (BanubaUtilities.KFCrossPlatformImage) throws -> BanubaUtilities.KFCrossPlatformImage)
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct RenderingModeImageModifier : BanubaUtilities.ImageModifier {
  public let renderingMode: UIKit.UIImage.RenderingMode
  public init(renderingMode: UIKit.UIImage.RenderingMode = .automatic)
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct FlipsForRightToLeftLayoutDirectionImageModifier : BanubaUtilities.ImageModifier {
  public init()
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct AlignmentRectInsetsImageModifier : BanubaUtilities.ImageModifier {
  public let alignmentInsets: UIKit.UIEdgeInsets
  public init(alignmentInsets: UIKit.UIEdgeInsets)
  public func modify(_ image: BanubaUtilities.KFCrossPlatformImage) -> BanubaUtilities.KFCrossPlatformImage
}
public struct MediaTrackTimeRange : Swift.Codable {
  public let startTime: CoreMedia.CMTime
  public let playingTimeRange: CoreMedia.CMTimeRange
  public init(startTime: CoreMedia.CMTime, playingTimeRange: CoreMedia.CMTimeRange)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public class MediaTrack : Swift.Codable {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var timeRange: BanubaUtilities.MediaTrackTimeRange
  final public let title: Swift.String?
  final public let additionalTitle: Swift.String?
  final public let isEditable: Swift.Bool
  public var id: CoreMedia.CMPersistentTrackID?
  public init(uuid: Foundation.UUID, id: CoreMedia.CMPersistentTrackID?, url: Foundation.URL, coverURL: Foundation.URL?, timeRange: BanubaUtilities.MediaTrackTimeRange, isEditable: Swift.Bool, title: Swift.String? = nil, additionalTitle: Swift.String? = nil)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class SessionDataTask {
  public typealias CancelToken = Swift.Int
  public var mutableData: Foundation.Data {
    get
  }
  final public let originalURL: Foundation.URL?
  final public let task: Foundation.URLSessionDataTask
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class BanubaAsyncOperation : Foundation.Operation {
  @objc override dynamic open var isReady: Swift.Bool {
    @objc get
  }
  @objc final override public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc final override public var isFinished: Swift.Bool {
    @objc get
  }
  @objc final override public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic open class func keyPathsForValuesAffectingValue(forKey key: Swift.String) -> Swift.Set<Swift.String>
  @objc final override public func start()
  @objc override dynamic open func main()
  final public func finish()
  @objc override dynamic public init()
  @objc deinit
}
public enum BackgroundViewStyle : Swift.Equatable {
  case blur(style: UIKit.UIBlurEffect.Style)
  case dim
  case none
  public static func == (a: BanubaUtilities.BackgroundViewStyle, b: BanubaUtilities.BackgroundViewStyle) -> Swift.Bool
}
public enum TransitionType : Swift.String, Swift.Codable, Swift.CaseIterable {
  case normal
  case whipDown
  case whipUp
  case whipRight
  case whipLeft
  case scrollDown
  case scrollUp
  case scrollRight
  case scrollLeft
  case spinRight
  case fade
  public init?(rawValue: Swift.String)
  public typealias AllCases = [BanubaUtilities.TransitionType]
  public typealias RawValue = Swift.String
  public static var allCases: [BanubaUtilities.TransitionType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension Dispatch.DispatchQueue {
  public static func checkAndPerformOnMainThreadAsync(_ block: @escaping () -> Swift.Void)
}
extension Swift.String {
  public func height(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
  public func width(forFont font: UIKit.UIFont) -> CoreFoundation.CGFloat
}
extension Swift.Double {
  public func rounded(toPlaces places: Swift.Int, rule: Swift.FloatingPointRoundingRule? = nil) -> Swift.Double
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  @discardableResult
  public func setImage(with source: BanubaUtilities.Source?, attributedView: @autoclosure @escaping () -> BanubaUtilities.KFCrossPlatformView, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any BanubaUtilities.Resource)?, attributedView: @autoclosure @escaping () -> BanubaUtilities.KFCrossPlatformView, placeholder: BanubaUtilities.KFCrossPlatformImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  public func cancelDownloadTask()
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.NSTextAttachment {
  public var taskIdentifier: BanubaUtilities.Source.Identifier.Value? {
    get
  }
}
@objc public class AlbumsConfiguration : ObjectiveC.NSObject {
  public var textButton: BanubaUtilities.TextButtonConfiguration
  public var arrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var backButton: BanubaUtilities.BackButtonConfiguration
  public var albumItemConfiguration: BanubaUtilities.AlbumItemConfiguration
  public var backgroundColor: UIKit.UIColor
  public init(textButton: BanubaUtilities.TextButtonConfiguration, arrowIconConfiguration: any BanubaUtilities.ImageConfigurationProtocol, backButton: BanubaUtilities.BackButtonConfiguration, albumItemConfiguration: BanubaUtilities.AlbumItemConfiguration, backgroundColor: UIKit.UIColor)
  @objc deinit
}
@objc public class AlbumItemConfiguration : ObjectiveC.NSObject {
  public var titleConfiguration: BanubaUtilities.TextConfiguration
  public var numberOfAlbumItemsConfiguration: BanubaUtilities.TextConfiguration
  public var coverCornerRadius: CoreFoundation.CGFloat
  public init(titleConfiguration: BanubaUtilities.TextConfiguration, numberOfAlbumItemsConfiguration: BanubaUtilities.TextConfiguration, coverCornerRadius: CoreFoundation.CGFloat)
  @objc deinit
}
public struct PlayerControlConfiguration {
  public var playButtonImageName: Swift.String
  public var pauseButtonImageName: Swift.String
  public var tintColor: UIKit.UIColor?
  public var playImage: UIKit.UIImage?
  public var pauseImage: UIKit.UIImage?
  public init(playButtonImageName: Swift.String, pauseButtonImageName: Swift.String, tintColor: UIKit.UIColor? = nil)
  public init(playImage: UIKit.UIImage?, pauseImage: UIKit.UIImage?)
}
@_hasMissingDesignatedInitializers open class Logger {
  open class func logError(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "")
  open class func logDegug(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "")
  open class func logInfo(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "")
  open class func logFault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "")
  open class func logDefault(_ message: Swift.String, subsystem: Swift.String = "com.banuba", category: Swift.String = "")
  @objc deinit
}
public struct AlertViewConfiguration {
  public var backgroundColor: UIKit.UIColor
  public var alertBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration
  public var resetButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var resetCancelTextConfig: BanubaUtilities.TextButtonConfiguration
  public var additionalButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var refuseButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var agreeButtonTextConfig: BanubaUtilities.TextButtonConfiguration
  public var titleTextConfig: BanubaUtilities.TextConfiguration
  public var messageTextConfig: BanubaUtilities.TextConfiguration
  public var spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat
  public var titleAndMessageInsets: UIKit.UIEdgeInsets
  public var preferredStatusBarStyle: UIKit.UIStatusBarStyle
  public init(backgroundColor: UIKit.UIColor, alertBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration, resetButtonTextConfig: BanubaUtilities.TextButtonConfiguration, resetCancelTextConfig: BanubaUtilities.TextButtonConfiguration, refuseButtonTextConfig: BanubaUtilities.TextButtonConfiguration, agreeButtonTextConfig: BanubaUtilities.TextButtonConfiguration, additionalButtonTextConfig: BanubaUtilities.TextButtonConfiguration, titleTextConfig: BanubaUtilities.TextConfiguration, messageTextConfig: BanubaUtilities.TextConfiguration, spacingBetweenTitleAndMessageLabels: CoreFoundation.CGFloat, titleAndMessageInsets: UIKit.UIEdgeInsets, preferredStatusBarStyle: UIKit.UIStatusBarStyle)
}
public typealias ExecutionQueue = BanubaUtilities.CallbackQueue
public enum CallbackQueue {
  case mainAsync
  case mainCurrentOrAsync
  case untouch
  case dispatch(Dispatch.DispatchQueue)
  public func execute(_ block: @escaping () -> Swift.Void)
}
public struct GalleryItemConfiguration {
  public var orderNumberBackgroudColor: UIKit.UIColor
  public var orderNumberSelectedBackgroudColor: UIKit.UIColor
  public var orderNumberTitleColor: UIKit.UIColor
  public var orderNumberTitleFont: UIKit.UIFont
  public var orderNumberBorderWidth: CoreFoundation.CGFloat
  public var orderNumberSelectedBorderWidth: CoreFoundation.CGFloat
  public var orderNumberBorderColor: UIKit.UIColor
  public var durationLabelConfiguration: BanubaUtilities.TextConfiguration
  public var durationLabelBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration
  public var durationLabelAlignment: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment
  public var activityIndicatorConfiguration: BanubaUtilities.SmallActivityIndicatorConfiguration
  public var cornerRadius: CoreFoundation.CGFloat
  public init(orderNumberBackgroudColor: UIKit.UIColor, orderNumberSelectedBackgroudColor: UIKit.UIColor, orderNumberTitleColor: UIKit.UIColor, orderNumberTitleFont: UIKit.UIFont, orderNumberBorderWidth: CoreFoundation.CGFloat, orderNumberSelectedBorderWidth: CoreFoundation.CGFloat, orderNumberBorderColor: UIKit.UIColor, durationLabelConfiguration: BanubaUtilities.TextConfiguration, durationLabelBackgroundConfiguration: BanubaUtilities.BackgroundConfiguration, durationLabelAlignment: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment, activityIndicatorConfiguration: BanubaUtilities.SmallActivityIndicatorConfiguration, cornerRadius: CoreFoundation.CGFloat)
  public enum DurationLabelAlignment {
    case left
    case right
    public static func == (a: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment, b: BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public enum KF {
  public static func source(_ source: BanubaUtilities.Source?) -> BanubaUtilities.KF.Builder
  public static func resource(_ resource: (any BanubaUtilities.Resource)?) -> BanubaUtilities.KF.Builder
  public static func url(_ url: Foundation.URL?, cacheKey: Swift.String? = nil) -> BanubaUtilities.KF.Builder
  public static func dataProvider(_ provider: (any BanubaUtilities.ImageDataProvider)?) -> BanubaUtilities.KF.Builder
  public static func data(_ data: Foundation.Data?, cacheKey: Swift.String) -> BanubaUtilities.KF.Builder
}
extension BanubaUtilities.KF {
  @_hasMissingDesignatedInitializers public class Builder {
    public var options: BanubaUtilities.KingfisherParsedOptionsInfo
    final public let onFailureDelegate: BanubaUtilities.Delegate<BanubaUtilities.KingfisherError, Swift.Void>
    final public let onSuccessDelegate: BanubaUtilities.Delegate<BanubaUtilities.RetrieveImageResult, Swift.Void>
    final public let onProgressDelegate: BanubaUtilities.Delegate<(Swift.Int64, Swift.Int64), Swift.Void>
    @objc deinit
  }
}
extension BanubaUtilities.KF.Builder {
  @discardableResult
  public func set(to imageView: BanubaUtilities.KFCrossPlatformImageView) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func set(to attachment: UIKit.NSTextAttachment, attributedView: @autoclosure @escaping () -> BanubaUtilities.KFCrossPlatformView) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func set(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setBackground(to button: UIKit.UIButton, for state: UIKit.UIControl.State) -> BanubaUtilities.DownloadTask?
}
extension BanubaUtilities.KF.Builder {
  public func placeholder(_ placeholder: (any BanubaUtilities.Placeholder)?) -> Self
  public func placeholder(_ image: BanubaUtilities.KFCrossPlatformImage?) -> Self
}
extension BanubaUtilities.KF.Builder {
  public func transition(_ transition: BanubaUtilities.ImageTransition) -> Self
  public func fade(duration: Foundation.TimeInterval) -> Self
  public func keepCurrentImageWhileLoading(_ enabled: Swift.Bool = true) -> Self
  public func onlyLoadFirstFrame(_ enabled: Swift.Bool = true) -> Self
  public func progressiveJPEG(_ progressive: BanubaUtilities.ImageProgressive? = .init()) -> Self
}
extension BanubaUtilities.KF.Builder {
  @available(*, deprecated, message: "This is not necessary anymore since `@StateObject` is used. It does nothing now and please just remove it.")
  public func loadImmediately(_ start: Swift.Bool = true) -> Self
}
extension BanubaUtilities.KF {
  public struct RedirectPayload {
    public let task: BanubaUtilities.SessionDataTask
    public let response: Foundation.HTTPURLResponse
    public let newRequest: Foundation.URLRequest
    public let completionHandler: (Foundation.URLRequest?) -> Swift.Void
  }
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) public func addArrangedSubviews(_ subviews: [UIKit.UIView])
  @_Concurrency.MainActor(unsafe) public func removeAllArrangedSubviews()
}
extension UIKit.UIStackView {
  @_Concurrency.MainActor(unsafe) public func addBackground(color: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat)
}
public protocol AudioItem {
  var uuid: Foundation.UUID { get }
  var url: Foundation.URL { get }
  var coverURL: Foundation.URL? { get }
  var title: Swift.String? { get set }
  var additionalTitle: Swift.String? { get set }
  var isEditable: Swift.Bool { get set }
}
extension CoreFoundation.CGFloat {
  public var gradientPoints: (CoreFoundation.CGPoint, CoreFoundation.CGPoint) {
    get
  }
}
@_inheritsConvenienceInitializers @objc(KFSessionDelegate) open class SessionDelegate : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension BanubaUtilities.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct ItemCollectionModel {
  public var assetCollection: Photos.PHAssetCollection
  public var previewAsset: Photos.PHAsset?
}
public protocol GalleryAdapter : AnyObject {
  var changesHandler: BanubaUtilities.GalleryManager.ChangesHandler? { get set }
  func checkAccessStatus(completion: @escaping (Swift.Bool) -> ())
  func getPreviewImageForGallery(completion: @escaping (UIKit.UIImage?) -> ())
  func fetchMediaAsset(from album: Photos.PHAssetCollection?, type: Photos.PHAssetMediaType, limit: Swift.Int?) -> [any BanubaUtilities.GalleryItem]
  func fetchSmartAlbums() -> [BanubaUtilities.ItemCollectionModel]
  func register()
}
extension BanubaUtilities.GalleryAdapter {
  public func fetchMediaAsset(from album: Photos.PHAssetCollection?, type: Photos.PHAssetMediaType, limit: Swift.Int? = nil) -> [any BanubaUtilities.GalleryItem]
}
@objc final public class GalleryManager : ObjectiveC.NSObject, BanubaUtilities.GalleryAdapter {
  final public let videoResolution: BanubaUtilities.VideoResolution
  final public let minimumDurationFromGallery: Foundation.TimeInterval
  final public var changesHandler: BanubaUtilities.GalleryManager.ChangesHandler?
  public typealias ChangesHandler = ((Photos.PHChange, [Photos.PHAsset]?, [Photos.PHAsset]?) -> Swift.Void)
  final public var authorizationStatus: Photos.PHAuthorizationStatus {
    get
  }
  final public var isCollectionsObserve: Swift.Bool
  required public init(isManuallyRegister: Swift.Bool, videoResolution: BanubaUtilities.VideoResolution, minimumDurationFromGallery: Foundation.TimeInterval)
  final public func register()
  final public func getPreviewImageForGallery(completion: @escaping (UIKit.UIImage?) -> ())
  final public func fetchAssets(in collection: Photos.PHAssetCollection, options: Photos.PHFetchOptions) -> Photos.PHFetchResult<Photos.PHAsset>
  @objc deinit
}
extension BanubaUtilities.GalleryManager : Photos.PHPhotoLibraryChangeObserver {
  @objc final public func photoLibraryDidChange(_ changeInstance: Photos.PHChange)
}
extension BanubaUtilities.GalleryManager {
  final public func fetchCollections(isNeedToStoreAssets: Swift.Bool) -> [BanubaUtilities.ItemCollectionModel]
  final public func fetchSmartAlbums() -> [BanubaUtilities.ItemCollectionModel]
  final public func fetchPhotoAndVideoAssets() -> [BanubaUtilities.BanubaGalleryItem]
  final public func fetchMediaAsset(from album: Photos.PHAssetCollection? = nil, type: Photos.PHAssetMediaType, limit: Swift.Int?) -> [any BanubaUtilities.GalleryItem]
  final public func checkAccessStatus(completion: @escaping (Swift.Bool) -> ())
}
extension BanubaUtilities.GalleryManager {
  public static func requestAccessIfNeeded(completion: @escaping (Swift.Bool) -> ())
}
public struct ImageCreatingOptions {
  public let scale: CoreFoundation.CGFloat
  public let duration: Foundation.TimeInterval
  public let preloadAll: Swift.Bool
  public let onlyFirstFrame: Swift.Bool
  public init(scale: CoreFoundation.CGFloat = 1.0, duration: Foundation.TimeInterval = 0.0, preloadAll: Swift.Bool = false, onlyFirstFrame: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers public class GIFAnimatedImage {
  public static func getFrameDuration(from gifInfo: [Swift.String : Any]?) -> Foundation.TimeInterval
  public static func getFrameDuration(from imageSource: ImageIO.CGImageSource, at index: Swift.Int) -> Foundation.TimeInterval
  @objc deinit
}
@objc public protocol GalleryViewControllerDelegate {
  @objc func galleryViewController(_ controller: BanubaUtilities.GalleryViewController, didStartExportWith progressHandler: BanubaUtilities.ProgressHandler)
  @objc func galleryViewController(_ controller: BanubaUtilities.GalleryViewController, didEndExportWith error: (any Swift.Error)?, hideProgressViewCompletion: @escaping () -> Swift.Void)
  @objc func galleryViewControllerDidClose(_ controller: BanubaUtilities.GalleryViewController)
  @objc func galleryViewControllerDone(_ controller: BanubaUtilities.GalleryViewController, withGalleryItems items: [any BanubaUtilities.GalleryItem])
  @objc func galleryViewControllerDoneForAutoCut(_ controller: BanubaUtilities.GalleryViewController, withGalleryItems items: [any BanubaUtilities.GalleryItem])
  @objc func galleryViewController(_ controller: BanubaUtilities.GalleryViewController, presentMessage message: Swift.String)
}
@objc public enum GalleryMediaType : Swift.Int, Swift.CaseIterable {
  case video
  case photo
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [BanubaUtilities.GalleryMediaType]
  public typealias RawValue = Swift.Int
  public static var allCases: [BanubaUtilities.GalleryMediaType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class GallerySelectionBehaviour : ObjectiveC.NSObject {
  final public let maximumSelectedCount: Swift.Int
  final public let selectedItemsCount: Swift.Int?
  final public let isMultiselectModeEnabled: Swift.Bool
  final public let minimumGalleryVideoDuration: Foundation.TimeInterval
  final public let allowedMediaTypes: [BanubaUtilities.GalleryMediaType]
  final public let slideshowDuration: Foundation.TimeInterval
  public init(maximumSelectedCount: Swift.Int, selectedItemsCount: Swift.Int? = nil, isMultiselectModeEnabled: Swift.Bool, minimumGalleryVideoDuration: Foundation.TimeInterval, allowedMediaTypes: [BanubaUtilities.GalleryMediaType], slideshowDuration: Foundation.TimeInterval)
  public var isAdditionalItemsRequired: Swift.Bool {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class GalleryViewController : UIKit.UIViewController, BanubaUtilities.AlertPresentable {
  @_Concurrency.MainActor(unsafe) weak open var delegate: (any BanubaUtilities.GalleryViewControllerDelegate)?
  @_Concurrency.MainActor(unsafe) open var configuration: BanubaUtilities.GalleryConfiguration?
  @_Concurrency.MainActor(unsafe) open var selectionBehaviour: BanubaUtilities.GallerySelectionBehaviour?
  @_Concurrency.MainActor(unsafe) open func useAlbum(_ albumView: any BanubaUtilities.AlbumModel)
  @_Concurrency.MainActor(unsafe) open func cancelExport()
  @_Concurrency.MainActor(unsafe) open func retryExport()
  @_Concurrency.MainActor(unsafe) open func getAlertViewController() -> BanubaUtilities.AlertViewController?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) open class AlbumsViewController : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) weak open var delegate: (any BanubaUtilities.AlbumsViewControllerDelegate)?
  @_Concurrency.MainActor(unsafe) open var configuration: BanubaUtilities.AlbumsConfiguration?
  @_Concurrency.MainActor(unsafe) open var selectedAlbum: (any BanubaUtilities.AlbumModel)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public protocol AlbumsViewControllerDelegate {
  @objc func albumsViewController(_ controller: BanubaUtilities.AlbumsViewController, didSelect album: any BanubaUtilities.AlbumModel)
  @objc func albumsViewControllerDidClose(_ controller: BanubaUtilities.AlbumsViewController)
}
@_inheritsConvenienceInitializers @objc public class ProgressHandler : ObjectiveC.NSObject {
  public var callback: ((Swift.Double) -> Swift.Void)?
  @objc override dynamic public init()
  @objc deinit
}
public struct CollectionInfoHeaderConfiguration {
  public var textConfiguration: BanubaUtilities.TextConfiguration
  public var hideButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol
  public var height: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var underlinedTextColor: UIKit.UIColor
  public init(textConfiguration: BanubaUtilities.TextConfiguration, hideButtonConfiguration: any BanubaUtilities.ImageButtonConfigurationProtocol, height: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, underlinedTextColor: UIKit.UIColor)
}
extension Swift.CaseIterable where Self : Swift.Equatable {
  public var next: Self {
    get
  }
}
public struct GalleryItemPreviewViewConfiguration {
  public var backgroundViewBlurStyle: UIKit.UIBlurEffect.Style
  public var selectionButtonView: BanubaUtilities.BackgroundConfiguration
  public var selectionButtonSelectText: BanubaUtilities.TextConfiguration
  public var selectionButtonDeselectText: BanubaUtilities.TextConfiguration
  public var selectionButtonSelectImageName: Swift.String
  public var selectionButtonDeselectImageName: Swift.String
  public var previewContainerView: BanubaUtilities.BackgroundConfiguration
  public init(backgroundViewBlurStyle: UIKit.UIBlurEffect.Style, selectionButtonView: BanubaUtilities.BackgroundConfiguration, selectionButtonSelectText: BanubaUtilities.TextConfiguration, selectionButtonDeselectText: BanubaUtilities.TextConfiguration, selectionButtonSelectImageName: Swift.String, selectionButtonDeselectImageName: Swift.String, previewContainerView: BanubaUtilities.BackgroundConfiguration)
}
public enum FileExtension {
  public enum Video : Swift.String {
    case mp4
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension Swift.Int32 {
  public static let `default`: CoreMedia.CMTimeScale
}
public struct DeviceVibrateManager {
  public static func vibrate(withPower power: UIKit.UIImpactFeedbackGenerator.FeedbackStyle)
}
public protocol CacheSerializer {
  func data(with image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  func image(with data: Foundation.Data, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
  var originalDataUsed: Swift.Bool { get }
}
extension BanubaUtilities.CacheSerializer {
  public var originalDataUsed: Swift.Bool {
    get
  }
}
public struct DefaultCacheSerializer : BanubaUtilities.CacheSerializer {
  public static let `default`: BanubaUtilities.DefaultCacheSerializer
  public var compressionQuality: CoreFoundation.CGFloat
  public var preferCacheOriginalData: Swift.Bool
  public var originalDataUsed: Swift.Bool {
    get
  }
  public init()
  public func data(with image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class CircularProgressView : UIKit.UIView, BanubaUtilities.ProgressAnimatableView {
  @_Concurrency.MainActor(unsafe) public var progressColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shadowColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var progress: Swift.Float {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var shadowLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var progressLineWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSublayers(of layer: QuartzCore.CALayer)
  @_Concurrency.MainActor(unsafe) public func resetProgress()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias KFCrossPlatformImage = UIKit.UIImage
public typealias KFCrossPlatformColor = UIKit.UIColor
public typealias KFCrossPlatformImageView = UIKit.UIImageView
public typealias KFCrossPlatformView = UIKit.UIView
public typealias KFCrossPlatformButton = UIKit.UIButton
public struct KingfisherWrapper<Base> {
  public let base: Base
  public init(_ base: Base)
}
public protocol KingfisherCompatible : AnyObject {
}
public protocol KingfisherCompatibleValue {
}
extension BanubaUtilities.KingfisherCompatible {
  public var kf: BanubaUtilities.KingfisherWrapper<Self> {
    get
    set
  }
}
extension BanubaUtilities.KingfisherCompatibleValue {
  public var kf: BanubaUtilities.KingfisherWrapper<Self> {
    get
    set
  }
}
extension UIKit.UIImage : BanubaUtilities.KingfisherCompatible {
}
extension UIKit.UIImageView : BanubaUtilities.KingfisherCompatible {
}
extension UIKit.UIButton : BanubaUtilities.KingfisherCompatible {
}
extension UIKit.NSTextAttachment : BanubaUtilities.KingfisherCompatible {
}
public typealias IndicatorView = UIKit.UIView
public enum IndicatorType {
  case none
  case activity(color: UIKit.UIColor)
  case image(imageData: Foundation.Data)
  case custom(indicator: any BanubaUtilities.Indicator)
}
public protocol Indicator {
  func startAnimatingView()
  func stopAnimatingView()
  var centerOffset: CoreFoundation.CGPoint { get }
  var view: BanubaUtilities.IndicatorView { get }
  func sizeStrategy(in imageView: BanubaUtilities.KFCrossPlatformImageView) -> BanubaUtilities.IndicatorSizeStrategy
}
public enum IndicatorSizeStrategy {
  case intrinsicSize
  case full
  case size(CoreFoundation.CGSize)
}
extension BanubaUtilities.Indicator {
  public var centerOffset: CoreFoundation.CGPoint {
    get
  }
  public func sizeStrategy(in imageView: BanubaUtilities.KFCrossPlatformImageView) -> BanubaUtilities.IndicatorSizeStrategy
}
@objc public protocol ImageConfigurationProtocol {
  @objc var image: UIKit.UIImage? { get }
  @objc var tintColor: UIKit.UIColor? { get }
}
public class BanubaImageConfiguration : BanubaUtilities.ImageConfigurationProtocol {
  @objc final public let image: UIKit.UIImage?
  @objc final public let tintColor: UIKit.UIColor?
  public init(image: UIKit.UIImage?, tintColor: UIKit.UIColor? = nil)
  @objc deinit
}
public protocol AnimatableView : UIKit.UIView {
  func start(completion: @escaping (Swift.Bool) -> Swift.Void)
  func stop()
}
public protocol CountdownTimerAnimatableView : BanubaUtilities.AnimatableView {
  var countdownDigit: Swift.Int { get set }
}
public protocol ProgressAnimatableView : UIKit.UIView {
  var progress: Swift.Float { get set }
}
@objc public protocol AppStateObserverDelegate {
  @objc func applicationWillResignActive(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc func applicationDidBecomeActive(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc optional func applicationWillEnterForeground(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc optional func applicationWillTerminateNotification(_ appStateObserver: BanubaUtilities.AppStateObserver)
  @objc optional func applicationDidEnterBackgroundNotification(_ appStateObserver: BanubaUtilities.AppStateObserver)
}
@_inheritsConvenienceInitializers @objc public class AppStateObserver : ObjectiveC.NSObject {
  weak public var delegate: (any BanubaUtilities.AppStateObserverDelegate)?
  public var appWillResignActive: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  convenience public init(delegate: (any BanubaUtilities.AppStateObserverDelegate)?)
  @objc deinit
}
extension BanubaUtilities.AppStateObserver {
  public func subscribeToNotifications()
  public func unsubscribeFromNotifications()
  @objc dynamic public func handleApplicationWillResignActiveNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleApplicationDidBecomeActiveNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleWillEnterForegroundNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleWillTerminateNotification(_ notification: Foundation.Notification)
  @objc dynamic public func handleDidEnterBackgroundNotification(_ notification: Foundation.Notification)
}
public protocol PlayerStateStorable {
  var playerState: Swift.Bool { get set }
}
public protocol ImageTextButtonConfigurationProtocol {
  var imageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? { get set }
  var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? { get set }
  var style: BanubaUtilities.TextConfiguration? { get set }
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func embed(toView view: UIKit.UIView, offset: CoreFoundation.CGFloat = .zero, forceLayoutPass: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func unembed()
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public var imageFrameCount: Swift.Int? {
    get
    set
  }
  public var imageSource: ImageIO.CGImageSource? {
    get
  }
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public var normalized: BanubaUtilities.KFCrossPlatformImage {
    get
  }
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public func pngRepresentation() -> Foundation.Data?
  public func jpegRepresentation(compressionQuality: CoreFoundation.CGFloat) -> Foundation.Data?
  public func gifRepresentation() -> Foundation.Data?
  public func data(format: BanubaUtilities.ImageFormat, compressionQuality: CoreFoundation.CGFloat = 1.0) -> Foundation.Data?
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public static func animatedImage(data: Foundation.Data, options: BanubaUtilities.ImageCreatingOptions) -> BanubaUtilities.KFCrossPlatformImage?
  public static func image(data: Foundation.Data, options: BanubaUtilities.ImageCreatingOptions) -> BanubaUtilities.KFCrossPlatformImage?
  public static func downsampledImage(data: Foundation.Data, to pointSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage?
}
public struct ToastConfiguration {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var cornerRadius: CoreFoundation.CGFloat
  public var textColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: UIKit.UIColor
  public var contentInsets: UIKit.UIEdgeInsets
  public var insets: UIKit.UIEdgeInsets
  public var icon: (any BanubaUtilities.ImageConfigurationProtocol)?
  public init(kern: Swift.Double, font: UIKit.UIFont, cornerRadius: CoreFoundation.CGFloat, textColor: UIKit.UIColor = .white, backgroundColor: UIKit.UIColor = .black, borderWidth: CoreFoundation.CGFloat = .zero, borderColor: UIKit.UIColor = .clear, contentInsets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 15.0,
      left: 15.0,
      bottom: 15.0,
      right: 15.0
    ), insets: UIKit.UIEdgeInsets = UIEdgeInsets(
      top: 70.0,
      left: 16.0,
      bottom: .zero,
      right: 16.0
    ), icon: (any BanubaUtilities.ImageConfigurationProtocol)? = nil)
}
extension BanubaUtilities.ToastConfiguration {
  public static var `default`: BanubaUtilities.ToastConfiguration {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class NibView : UIKit.UIView, BanubaUtilities.NibLoadable {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func commonInit()
  @objc deinit
}
public enum MemoryStorage {
  public class Backend<T> where T : BanubaUtilities.CacheCostCalculable {
    public var config: BanubaUtilities.MemoryStorage.Config {
      get
      set
    }
    public init(config: BanubaUtilities.MemoryStorage.Config)
    public func removeExpired()
    public func store(value: T, forKey key: Swift.String, expiration: BanubaUtilities.StorageExpiration? = nil)
    public func value(forKey key: Swift.String, extendingExpiration: BanubaUtilities.ExpirationExtending = .cacheTime) -> T?
    public func isCached(forKey key: Swift.String) -> Swift.Bool
    public func remove(forKey key: Swift.String)
    public func removeAll()
    @objc deinit
  }
}
extension BanubaUtilities.MemoryStorage {
  public struct Config {
    public var totalCostLimit: Swift.Int
    public var countLimit: Swift.Int
    public var expiration: BanubaUtilities.StorageExpiration
    public var cleanInterval: Foundation.TimeInterval
    public var keepWhenEnteringBackground: Swift.Bool
    public init(totalCostLimit: Swift.Int, cleanInterval: Foundation.TimeInterval = 120)
  }
}
public struct GalleryLayoutConfiguration {
  public var numberOfItemsPerRow: Swift.Int
  public var interitemSpacing: CoreFoundation.CGFloat
  public var edgeInsets: UIKit.UIEdgeInsets
  public init(numberOfItemsPerRow: Swift.Int, interitemSpacing: CoreFoundation.CGFloat, edgeInsets: UIKit.UIEdgeInsets)
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIButton {
  @discardableResult
  public func setImage(with source: BanubaUtilities.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any BanubaUtilities.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with source: BanubaUtilities.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, parsedOptions: BanubaUtilities.KingfisherParsedOptionsInfo, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  public func cancelImageDownloadTask()
  @discardableResult
  public func setBackgroundImage(with source: BanubaUtilities.Source?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setBackgroundImage(with resource: (any BanubaUtilities.Resource)?, for state: UIKit.UIControl.State, placeholder: UIKit.UIImage? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  public func cancelBackgroundImageDownloadTask()
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIButton {
  public func taskIdentifier(for state: UIKit.UIControl.State) -> BanubaUtilities.Source.Identifier.Value?
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIButton {
  public func backgroundTaskIdentifier(for state: UIKit.UIControl.State) -> BanubaUtilities.Source.Identifier.Value?
}
public protocol ReusableView : AnyObject {
}
extension BanubaUtilities.ReusableView {
  public static var reuseIdentifier: Swift.String {
    get
  }
}
public struct BackButtonConfiguration {
  public var imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public var selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)?
  public var position: BanubaUtilities.BackButtonConfiguration.Position?
  public var menuActions: [BanubaUtilities.PopoverAlertViewController.ActionType]
  @frozen public enum Position {
    case left
    case right
    public static func == (a: BanubaUtilities.BackButtonConfiguration.Position, b: BanubaUtilities.BackButtonConfiguration.Position) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(imageConfiguration: any BanubaUtilities.ImageConfigurationProtocol, selectedImageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)? = nil, position: BanubaUtilities.BackButtonConfiguration.Position? = nil, menuActions: [BanubaUtilities.PopoverAlertViewController.ActionType] = [])
}
public enum DrawableFigure : Swift.String, Swift.Codable {
  case circle
  case square
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public func image(withBlendMode blendMode: CoreGraphics.CGBlendMode, alpha: CoreFoundation.CGFloat = 1.0, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> BanubaUtilities.KFCrossPlatformImage
  public func image(withRadius radius: BanubaUtilities.Radius, fit size: CoreFoundation.CGSize, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> BanubaUtilities.KFCrossPlatformImage
  public func image(withRoundRadius radius: CoreFoundation.CGFloat, fit size: CoreFoundation.CGSize, roundingCorners corners: BanubaUtilities.RectCorner = .all, backgroundColor: BanubaUtilities.KFCrossPlatformColor? = nil) -> BanubaUtilities.KFCrossPlatformImage
  public func resize(to size: CoreFoundation.CGSize) -> BanubaUtilities.KFCrossPlatformImage
  public func resize(to targetSize: CoreFoundation.CGSize, for contentMode: BanubaUtilities.ContentMode) -> BanubaUtilities.KFCrossPlatformImage
  public func crop(to size: CoreFoundation.CGSize, anchorOn anchor: CoreFoundation.CGPoint) -> BanubaUtilities.KFCrossPlatformImage
  public func blurred(withRadius radius: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func addingBorder(_ border: BanubaUtilities.Border) -> BanubaUtilities.KFCrossPlatformImage
  public func overlaying(with color: BanubaUtilities.KFCrossPlatformColor, fraction: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func tinted(with color: BanubaUtilities.KFCrossPlatformColor) -> BanubaUtilities.KFCrossPlatformImage
  public func adjusted(brightness: CoreFoundation.CGFloat, contrast: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, inputEV: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func scaled(to scale: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImage {
  public var decoded: BanubaUtilities.KFCrossPlatformImage {
    get
  }
  public func decoded(scale: CoreFoundation.CGFloat) -> BanubaUtilities.KFCrossPlatformImage
  public func decoded(on context: CoreGraphics.CGContext) -> BanubaUtilities.KFCrossPlatformImage
}
public class AudioServiceItem : BanubaUtilities.AudioItem {
  final public let uuid: Foundation.UUID
  final public let url: Foundation.URL
  final public let coverURL: Foundation.URL?
  public var title: Swift.String?
  public var additionalTitle: Swift.String?
  public var isEditable: Swift.Bool
  public var timeRange: CoreMedia.CMTimeRange?
  public init(uuid: Foundation.UUID, url: Foundation.URL, coverURL: Foundation.URL?, title: Swift.String?, additionalTitle: Swift.String?, isEditable: Swift.Bool, timeRange: CoreMedia.CMTimeRange? = nil)
  @objc deinit
}
public protocol AudioPlayerDelegate : AnyObject {
  func playerPlaysFrameAtTime(_ time: Foundation.TimeInterval)
  func didEndPlaying()
}
public protocol AudioServicing {
  var player: AVFAudio.AVAudioPlayer? { get set }
  var delegate: (any BanubaUtilities.AudioPlayerDelegate)? { get set }
  var rate: Swift.Float { get set }
  var currentAudio: BanubaUtilities.AudioServiceItem? { get }
  var duration: Foundation.TimeInterval? { get }
  func autoRepeat(repeat: Swift.Bool, delay: Swift.Double)
  func seekToStart()
  func seekToStart(isEnabled: Swift.Bool)
  func seek(to: Foundation.TimeInterval)
  func load(item: BanubaUtilities.AudioServiceItem) throws
  func unload()
  func toggle()
  func play()
  func pause()
  func setRate(_ rate: Swift.Float)
  func setDelegate(_ delegate: any BanubaUtilities.AudioPlayerDelegate)
  func changeVolume(volume: Swift.Float)
  func createAudioDirectory()
}
@objc @_inheritsConvenienceInitializers public class AudioService : ObjectiveC.NSObject, BanubaUtilities.AudioServicing {
  weak public var delegate: (any BanubaUtilities.AudioPlayerDelegate)?
  public var currentAudio: BanubaUtilities.AudioServiceItem?
  public var player: AVFAudio.AVAudioPlayer?
  public var duration: Foundation.TimeInterval? {
    get
  }
  public var playingTimeRange: CoreMedia.CMTimeRange?
  public var rate: Swift.Float {
    get
    set
  }
  public func autoRepeat(repeat: Swift.Bool)
  public func autoRepeat(repeat: Swift.Bool, delay: Swift.Double = .zero)
  public func seekToStart(isEnabled: Swift.Bool)
  public func createAudioDirectory()
  public func setRate(_ rate: Swift.Float)
  public func changeVolume(volume: Swift.Float)
  public func load(item: BanubaUtilities.AudioServiceItem) throws
  public func load(trackUrl: Foundation.URL) throws
  public func unload()
  public func toggle()
  public func play()
  public func pause()
  public func seekToStart()
  public func seek(to: Foundation.TimeInterval)
  public func setDelegate(_ delegate: any BanubaUtilities.AudioPlayerDelegate)
  @objc override dynamic public init()
  @objc deinit
}
extension BanubaUtilities.AudioService : AVFAudio.AVAudioPlayerDelegate {
  @objc dynamic public func audioPlayerDidFinishPlaying(_ player: AVFAudio.AVAudioPlayer, successfully flag: Swift.Bool)
}
extension BanubaUtilities.AudioServicing {
  public var musicTrack: BanubaUtilities.MediaTrack? {
    get
  }
}
@objc public enum GalleryItemType : Swift.Int {
  case photo
  case video
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol GalleryItem : ObjectiveC.NSObjectProtocol {
  @objc var urlAsset: AVFoundation.AVURLAsset? { get }
  @objc var preview: UIKit.UIImage? { get set }
  @objc var duration: Foundation.TimeInterval { get }
  @objc var type: BanubaUtilities.GalleryItemType { get }
  @objc func requestPreview(size: CoreFoundation.CGSize, synchronously: Swift.Bool, handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc func requestPhoto(size: CoreFoundation.CGSize, progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)
  @objc func requestAVURLAsset(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVURLAsset?, (any Swift.Error)?) -> Swift.Void)
  @objc func requestAVPlayerItem(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVPlayerItem?, (any Swift.Error)?) -> Swift.Void)
}
@objc open class BanubaGalleryItem : ObjectiveC.NSObject, BanubaUtilities.GalleryItem {
  public static let defaultPreviewSize: CoreFoundation.CGSize
  final public let asset: Photos.PHAsset
  final public let videoResolution: BanubaUtilities.VideoResolution
  @objc public var preview: UIKit.UIImage?
  @objc public var duration: Foundation.TimeInterval {
    @objc get
  }
  @objc public var urlAsset: AVFoundation.AVURLAsset? {
    get
  }
  @objc public var type: BanubaUtilities.GalleryItemType {
    @objc get
  }
  public init(asset: Photos.PHAsset, videoResolution: BanubaUtilities.VideoResolution)
  @objc open func requestAVURLAsset(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVURLAsset?, (any Swift.Error)?) -> Swift.Void)
  @objc open func requestAVPlayerItem(progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (AVFoundation.AVPlayerItem?, (any Swift.Error)?) -> Swift.Void)
  @objc open func requestPreview(size: CoreFoundation.CGSize = BanubaGalleryItem.defaultPreviewSize, synchronously: Swift.Bool, handler: @escaping (UIKit.UIImage?) -> Swift.Void)
  @objc open func requestPhoto(size: CoreFoundation.CGSize, progressHandler: ((Swift.Double) -> (Swift.Bool))?, handler: @escaping (UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
extension BanubaUtilities.BanubaGalleryItem {
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
}
@objc public protocol GalleryViewControllerFactory : ObjectiveC.NSObjectProtocol {
  @objc func makeGalleryViewController(withConfiguration configuration: BanubaUtilities.GalleryConfiguration, albumsConfiguration: BanubaUtilities.AlbumsConfiguration, selectionBehaviour: BanubaUtilities.GallerySelectionBehaviour) -> BanubaUtilities.GalleryViewController
}
public protocol ImageDownloadRedirectHandler {
  func handleHTTPRedirection(for task: BanubaUtilities.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct AnyRedirectHandler : BanubaUtilities.ImageDownloadRedirectHandler {
  public func handleHTTPRedirection(for task: BanubaUtilities.SessionDataTask, response: Foundation.HTTPURLResponse, newRequest: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  public init(handle: @escaping (BanubaUtilities.SessionDataTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)
}
public struct AudioPartSelectionViewConfiguration {
  public static var dark: BanubaUtilities.AudioPartSelectionViewConfiguration {
    get
  }
  public static var light: BanubaUtilities.AudioPartSelectionViewConfiguration {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class AudioPartSelectionView : UIKit.UIView, UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) final public var didScrollHandler: ((CoreMedia.CMTimeRange) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) final public func set(audioStartOffset: Foundation.TimeInterval = .zero, audioDuration: Foundation.TimeInterval, videoDuration: Foundation.TimeInterval)
  @_Concurrency.MainActor(unsafe) final public func set(playbackProgress: Swift.Double)
  @_Concurrency.MainActor(unsafe) final public func showAudioAmplitude(samples: [Swift.Float])
  @_Concurrency.MainActor(unsafe) final public func apply(configuration: BanubaUtilities.AudioPartSelectionViewConfiguration)
  @_Concurrency.MainActor(unsafe) final public func stopSelectionAnimationIfNeeded()
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) final public func setPlayedRangeOverlayViewHidden(_ isHidden: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func updatePlayedRangeOverlayViewLayer(completion: (() -> Swift.Void)? = nil)
  @objc deinit
}
extension Swift.Array where Element : Swift.Hashable {
  public func uniqued() -> [Element]
}
extension Swift.Error {
  public var errorMessage: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class RetryContext {
  final public let source: BanubaUtilities.Source
  final public let error: BanubaUtilities.KingfisherError
  public var retriedCount: Swift.Int
  public var userInfo: Any? {
    get
  }
  @objc deinit
}
public enum RetryDecision {
  case retry(userInfo: Any?)
  case stop
}
public protocol RetryStrategy {
  func retry(context: BanubaUtilities.RetryContext, retryHandler: @escaping (BanubaUtilities.RetryDecision) -> Swift.Void)
}
public struct DelayRetryStrategy : BanubaUtilities.RetryStrategy {
  public enum Interval {
    case seconds(Foundation.TimeInterval)
    case accumulated(Foundation.TimeInterval)
    case custom(block: (_ retriedCount: Swift.Int) -> Foundation.TimeInterval)
  }
  public let maxRetryCount: Swift.Int
  public let retryInterval: BanubaUtilities.DelayRetryStrategy.Interval
  public init(maxRetryCount: Swift.Int, retryInterval: BanubaUtilities.DelayRetryStrategy.Interval = .seconds(3))
  public func retry(context: BanubaUtilities.RetryContext, retryHandler: @escaping (BanubaUtilities.RetryDecision) -> Swift.Void)
}
public struct FormatIndicatedCacheSerializer : BanubaUtilities.CacheSerializer {
  public static let png: BanubaUtilities.FormatIndicatedCacheSerializer
  public static let jpeg: BanubaUtilities.FormatIndicatedCacheSerializer
  public static func jpeg(compressionQuality: CoreFoundation.CGFloat) -> BanubaUtilities.FormatIndicatedCacheSerializer
  public static let gif: BanubaUtilities.FormatIndicatedCacheSerializer
  public func data(with image: BanubaUtilities.KFCrossPlatformImage, original: Foundation.Data?) -> Foundation.Data?
  public func image(with data: Foundation.Data, options: BanubaUtilities.KingfisherParsedOptionsInfo) -> BanubaUtilities.KFCrossPlatformImage?
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func dropShadow(_ offset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), blur: CoreFoundation.CGFloat = 1, opacity: Swift.Float = 1)
}
@objc public class SmallActivityIndicatorConfiguration : ObjectiveC.NSObject {
  @objc public enum GradientTypeAdapter : Swift.Int {
    case color
    case image
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public class GradientType : ObjectiveC.NSObject {
    public var type: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter
    public var color: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientColorConfiguration?
    public var image: (any BanubaUtilities.ImageConfigurationProtocol)?
    public init(type: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter, color: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientColorConfiguration?, image: (any BanubaUtilities.ImageConfigurationProtocol)?)
    @objc deinit
  }
  @objc public class GradientColorConfiguration : ObjectiveC.NSObject {
    public var angle: CoreFoundation.CGFloat
    public var colors: [CoreGraphics.CGColor]
    public init(angle: CoreFoundation.CGFloat, colors: [CoreGraphics.CGColor])
    @objc deinit
  }
  public var gradientType: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType
  public var activityLineWidth: CoreFoundation.CGFloat
  public init(gradientType: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType, activityLineWidth: CoreFoundation.CGFloat)
  @objc deinit
}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType {
  @objc public static func color(_ color: BanubaUtilities.SmallActivityIndicatorConfiguration.GradientColorConfiguration) -> BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType
  @objc public static func image(_ image: any BanubaUtilities.ImageConfigurationProtocol) -> BanubaUtilities.SmallActivityIndicatorConfiguration.GradientType
}
public struct AutoCutGalleryConfiguration {
  public let normalApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration
  public let disabledApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration
  public let normalNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration
  public let disabledNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration
  public let maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval
  public init(normalApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration, disabledApplyAutoCutButtonConfiguration: BanubaUtilities.ApplyAutoCutButtonConfiguration, normalNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration, disabledNextButtonConfiguration: BanubaUtilities.GalleryNextButtonConfiguration, maximumDurationOfAutoCutSourceVideos: Foundation.TimeInterval)
}
public struct ApplyAutoCutButtonConfiguration {
  public let borderColor: UIKit.UIColor
  public let iconConfiguration: any BanubaUtilities.ImageConfigurationProtocol
  public let textConfiguration: BanubaUtilities.TextConfiguration
  public init(borderColor: UIKit.UIColor, iconConfiguration: any BanubaUtilities.ImageConfigurationProtocol, textConfiguration: BanubaUtilities.TextConfiguration)
}
public struct GalleryNextButtonConfiguration {
  public let textConfiguration: BanubaUtilities.TextConfiguration
  public let backgroundColor: UIKit.UIColor
  public init(textConfiguration: BanubaUtilities.TextConfiguration, backgroundColor: UIKit.UIColor)
}
public enum VideoResolution : Swift.String {
  case uhd3840x2160
  case qhd2560x1440
  case hd1920x1080
  case hd1280x720
  case md960x540
  case default854x480
  public var isFullHDEnabled: Swift.Bool {
    get
  }
  public var сaptureSessionPreset: AVFoundation.AVCaptureSession.Preset {
    get
  }
  public var assetExportPreset: Swift.String {
    get
  }
  public var size: CoreFoundation.CGSize {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CameraVideoResolution {
  case auto
  case vga854x480
  case hd1280x720
  case hd1920x1080
  public var сaptureSessionPreset: AVFoundation.AVCaptureSession.Preset? {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  public static func == (a: BanubaUtilities.CameraVideoResolution, b: BanubaUtilities.CameraVideoResolution) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct VideoResolutionConfiguration {
  public var `default`: BanubaUtilities.VideoResolution
  public var cameraVideoResolution: BanubaUtilities.CameraVideoResolution
  public let resolutions: [BanubaUtilities.DeviceModel : BanubaUtilities.VideoResolution]
  public let thumbnailHeights: [BanubaUtilities.DeviceModel : CoreFoundation.CGFloat]
  public let defaultThumbnailHeight: CoreFoundation.CGFloat
  public var current: BanubaUtilities.VideoResolution {
    get
  }
  public var currentThumbnailHeight: CoreFoundation.CGFloat {
    get
  }
  public init(default: BanubaUtilities.VideoResolution, cameraVideoResolution: BanubaUtilities.CameraVideoResolution = .auto, resolutions: [BanubaUtilities.DeviceModel : BanubaUtilities.VideoResolution], thumbnailHeights: [BanubaUtilities.DeviceModel : CoreFoundation.CGFloat], defaultThumbnailHeight: CoreFoundation.CGFloat)
}
extension AVFoundation.AVCaptureSession.Preset {
  public mutating func downgrade()
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImageView {
  @discardableResult
  public func setImage(with source: BanubaUtilities.Source?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with source: BanubaUtilities.Source?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any BanubaUtilities.Resource)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with resource: (any BanubaUtilities.Resource)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with provider: (any BanubaUtilities.ImageDataProvider)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, progressBlock: BanubaUtilities.DownloadProgressBlock? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  @discardableResult
  public func setImage(with provider: (any BanubaUtilities.ImageDataProvider)?, placeholder: (any BanubaUtilities.Placeholder)? = nil, options: BanubaUtilities.KingfisherOptionsInfo? = nil, completionHandler: ((Swift.Result<BanubaUtilities.RetrieveImageResult, BanubaUtilities.KingfisherError>) -> Swift.Void)? = nil) -> BanubaUtilities.DownloadTask?
  public func cancelDownloadTask()
}
extension BanubaUtilities.KingfisherWrapper where Base : UIKit.UIImageView {
  public var taskIdentifier: BanubaUtilities.Source.Identifier.Value? {
    get
  }
  public var indicatorType: BanubaUtilities.IndicatorType {
    get
    set
  }
  public var indicator: (any BanubaUtilities.Indicator)? {
    get
  }
  public var placeholder: (any BanubaUtilities.Placeholder)? {
    get
  }
}
public struct BorderButtonConfiguration {
  public var borderWidth: CoreFoundation.CGFloat
  public var borderColor: CoreGraphics.CGColor
  public init(borderWidth: CoreFoundation.CGFloat, borderColor: CoreGraphics.CGColor)
}
public struct RoundedButtonConfiguration {
  public var textConfiguration: BanubaUtilities.TextConfiguration?
  public var borderWidth: CoreFoundation.CGFloat?
  public var borderColor: CoreGraphics.CGColor?
  public var cornerRadius: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor
  public var width: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public var titleSpacing: CoreFoundation.CGFloat?
  public init(textConfiguration: BanubaUtilities.TextConfiguration?, cornerRadius: CoreFoundation.CGFloat, backgroundColor: UIKit.UIColor, borderWidth: CoreFoundation.CGFloat? = nil, borderColor: CoreGraphics.CGColor? = nil, width: CoreFoundation.CGFloat = 70.0, height: CoreFoundation.CGFloat = 30.0, titleSpacing: CoreFoundation.CGFloat? = 2.0)
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) public func applyConfiguration(_ imageConfiguration: (any BanubaUtilities.ImageConfigurationProtocol)?)
}
extension Swift.Error {
  public var isCancelled: Swift.Bool {
    get
  }
  public var isNetworkUnavailable: Swift.Bool {
    get
  }
}
extension Foundation.NSError {
  public static func makeCancelledError(domain: Swift.String) -> Foundation.NSError
}
extension CoreFoundation.CGSize {
  public func swap() -> CoreFoundation.CGSize
}
public class PreviewExtractor {
  final public let asset: AVFoundation.AVAsset
  final public let thumbnailHeight: CoreFoundation.CGFloat
  public var imageGenerator: AVFoundation.AVAssetImageGenerator
  public init(asset: AVFoundation.AVAsset, thumbnailHeight: CoreFoundation.CGFloat)
  @objc deinit
  public func extractPreview(at time: CoreMedia.CMTime) -> UIKit.UIImage?
  #if compiler(>=5.3) && $AsyncAwait
  public func extractPreview(at time: CoreMedia.CMTime) async -> UIKit.UIImage?
  #endif
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func roundCorners(cornerMask: QuartzCore.CACornerMask, radius: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public func roundCorners(radius: CoreFoundation.CGFloat)
}
extension CoreMedia.CMTime : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var keyboardLayoutGuide: UIKit.UILayoutGuide {
    get
  }
  @_Concurrency.MainActor(unsafe) public var keyboardLayoutGuideNoSafeArea: UIKit.UILayoutGuide {
    get
  }
}
@objc @_Concurrency.MainActor(unsafe) open class KeyboardLayoutGuide : UIKit.UILayoutGuide {
  @_Concurrency.MainActor(unsafe) public var usesSafeArea: Swift.Bool {
    get
    set
  }
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(notificationCenter: Foundation.NotificationCenter = NotificationCenter.default)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class VideoEditorActivityIndicator : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var configuration: BanubaUtilities.SmallActivityIndicatorConfiguration? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func startAnimating()
  @_Concurrency.MainActor(unsafe) public func stopAnimating()
  @objc deinit
}
public enum OverlayPopoverActionsPosition {
  case bottomLeft(_: CoreFoundation.CGPoint)
  case topLeft(_: CoreFoundation.CGPoint)
  case topRight(_: CoreFoundation.CGPoint)
  case bottomRight(_: CoreFoundation.CGPoint)
  case center
}
public struct PopoverAlertViewConfiguration {
  public var mainBackgroundColor: UIKit.UIColor
  public var actionsViewBackgroundColor: UIKit.UIColor
  public var cornerRadius: CoreFoundation.CGFloat
  public var actionCellHeight: CoreFoundation.CGFloat
  public var hideAnimated: Swift.Bool
  public static var `default`: BanubaUtilities.PopoverAlertViewConfiguration {
    get
  }
  public init(mainBackgroundColor: UIKit.UIColor, actionsViewBackgroundColor: UIKit.UIColor, cornerRadius: CoreFoundation.CGFloat, actionCellHeight: CoreFoundation.CGFloat, hideAnimated: Swift.Bool)
}
public struct OverlayPopoverActionConfiguration {
  public init(leftImage: (any BanubaUtilities.ImageConfigurationProtocol)?, rightImage: (any BanubaUtilities.ImageConfigurationProtocol)?, title: BanubaUtilities.TextConfiguration, titleImageInset: CoreFoundation.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class PopoverAlertViewController : UIKit.UIViewController, BanubaUtilities.NibLoadable {
  public enum ActionType {
    case edit(BanubaUtilities.OverlayPopoverActionConfiguration)
    case delete(BanubaUtilities.OverlayPopoverActionConfiguration)
    case discardChanges(BanubaUtilities.OverlayPopoverActionConfiguration)
    case updateDraft(BanubaUtilities.OverlayPopoverActionConfiguration)
  }
  @_Concurrency.MainActor(unsafe) public var configuration: BanubaUtilities.PopoverAlertViewConfiguration
  @_Concurrency.MainActor(unsafe) public var actions: [BanubaUtilities.PopoverAlertViewController.ActionType]
  @_Concurrency.MainActor(unsafe) public var actionsPosition: BanubaUtilities.OverlayPopoverActionsPosition
  @_Concurrency.MainActor(unsafe) public var resultCompletion: ((BanubaUtilities.PopoverAlertViewController.ActionType) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillLayoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension BanubaUtilities.PopoverAlertViewController : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
public class ToastPresenter {
  public init(configuration: BanubaUtilities.ToastConfiguration, toastLifeTime: Foundation.TimeInterval? = nil)
  @objc deinit
  public func showToast(message: Swift.String)
}
extension Foundation.NSNotification.Name {
  public static let videoEditorPlayerCurrentTimeChanged: Foundation.Notification.Name
}
public protocol VideoEditorPlayable : AnyObject {
  var isPlaying: Swift.Bool { get }
  var playerItem: AVFoundation.AVPlayerItem? { get }
  var avPlayer: AVFoundation.AVPlayer { get }
  var currentTime: CoreMedia.CMTime { get }
  var videoDuration: CoreMedia.CMTime { get }
  var playingRange: CoreMedia.CMTimeRange { get }
  var isMuted: Swift.Bool { get set }
  var audioMix: AVFoundation.AVAudioMix? { get set }
  var playerDelegate: (any BanubaUtilities.VideoEditorPlayerDelegate)? { get set }
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool)
  func play(loop: Swift.Bool, fixedSpeed: Swift.Bool, range: CoreMedia.CMTimeRange)
  func pause()
  func seek(to time: CoreMedia.CMTime)
  func smoothlySeek(to time: CoreMedia.CMTime)
  func reloadPreview(shouldAutoStart: Swift.Bool)
}
public protocol VideoEditorPlayerDelegate : AnyObject {
  func playerPlaysFrame(_ player: any BanubaUtilities.VideoEditorPlayable, atTime time: CoreMedia.CMTime)
  func playerDidEndPlaying(_ player: any BanubaUtilities.VideoEditorPlayable)
}
public protocol NibLoadable : AnyObject {
  static var nib: UIKit.UINib { get }
}
extension BanubaUtilities.NibLoadable {
  public static var nib: UIKit.UINib {
    get
  }
}
extension BanubaUtilities.NibLoadable where Self : UIKit.UIView {
  public static func loadFromNib() -> Self
}
public enum ImageFormat {
  case unknown
  case PNG
  case JPEG
  case GIF
  public enum JPEGMarker {
    case SOF0
    case SOF2
    case DHT
    case DQT
    case DRI
    case SOS
    case RSTn(Swift.UInt8)
    case APPn
    case COM
    case EOI
  }
  public static func == (a: BanubaUtilities.ImageFormat, b: BanubaUtilities.ImageFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Data : BanubaUtilities.KingfisherCompatibleValue {
}
extension BanubaUtilities.KingfisherWrapper where Base == Foundation.Data {
  public var imageFormat: BanubaUtilities.ImageFormat {
    get
  }
  public func contains(jpeg marker: BanubaUtilities.ImageFormat.JPEGMarker) -> Swift.Bool
}
@available(*, deprecated, renamed: "AuthenticationChallengeResponsible", message: "Typo. Use `AuthenticationChallengeResponsible` instead")
public typealias AuthenticationChallengeResponsable = BanubaUtilities.AuthenticationChallengeResponsible
public protocol AuthenticationChallengeResponsible : AnyObject {
  func downloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  func downloader(_ downloader: BanubaUtilities.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
extension BanubaUtilities.AuthenticationChallengeResponsible {
  public func downloader(_ downloader: BanubaUtilities.ImageDownloader, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  public func downloader(_ downloader: BanubaUtilities.ImageDownloader, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
}
@objc public class TextConfiguration : ObjectiveC.NSObject {
  public var kern: Swift.Double
  public var font: UIKit.UIFont
  public var color: UIKit.UIColor
  public var alignment: UIKit.NSTextAlignment
  public var text: Swift.String?
  public var shadow: BanubaUtilities.TextShadowConfiguration?
  public var lineBreakMode: UIKit.NSLineBreakMode
  public init(kern: Swift.Double = 0, font: UIKit.UIFont, color: UIKit.UIColor, alignment: UIKit.NSTextAlignment = .center, text: Swift.String? = nil, shadow: BanubaUtilities.TextShadowConfiguration? = nil, lineBreakMode: UIKit.NSLineBreakMode = .byWordWrapping)
  @objc override dynamic public func copy() -> Any
  @objc deinit
}
public struct TextShadowConfiguration {
  public var shadowColor: UIKit.UIColor
  public var shadowOffset: CoreFoundation.CGSize
  public var shadowBlurRadius: CoreFoundation.CGFloat
  public init(shadowColor: UIKit.UIColor = UIColor.black.withAlphaComponent(0.4), shadowOffset: CoreFoundation.CGSize = CGSize(width: 0, height: 1), shadowBlurRadius: CoreFoundation.CGFloat = 2.0)
  public func shadow() -> UIKit.NSShadow
}
extension BanubaUtilities.AlertViewController.ButtonType : Swift.Equatable {}
extension BanubaUtilities.AlertViewController.ButtonType : Swift.Hashable {}
extension BanubaUtilities.AspectRatio : Swift.Equatable {}
extension BanubaUtilities.AspectRatio : Swift.Hashable {}
extension BanubaUtilities.AspectRatio : Swift.RawRepresentable {}
extension BanubaUtilities.Connection : Swift.Equatable {}
extension BanubaUtilities.Connection : Swift.Hashable {}
extension BanubaUtilities.ContentMode : Swift.Equatable {}
extension BanubaUtilities.ContentMode : Swift.Hashable {}
extension BanubaUtilities.CacheType : Swift.Equatable {}
extension BanubaUtilities.CacheType : Swift.Hashable {}
extension BanubaUtilities.DeviceModel : Swift.Equatable {}
extension BanubaUtilities.DeviceModel : Swift.Hashable {}
extension BanubaUtilities.DeviceModel : Swift.RawRepresentable {}
extension BanubaUtilities.TransitionType : Swift.Equatable {}
extension BanubaUtilities.TransitionType : Swift.Hashable {}
extension BanubaUtilities.TransitionType : Swift.RawRepresentable {}
extension BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment : Swift.Equatable {}
extension BanubaUtilities.GalleryItemConfiguration.DurationLabelAlignment : Swift.Hashable {}
extension BanubaUtilities.GalleryMediaType : Swift.Equatable {}
extension BanubaUtilities.GalleryMediaType : Swift.Hashable {}
extension BanubaUtilities.GalleryMediaType : Swift.RawRepresentable {}
extension BanubaUtilities.FileExtension.Video : Swift.Equatable {}
extension BanubaUtilities.FileExtension.Video : Swift.Hashable {}
extension BanubaUtilities.FileExtension.Video : Swift.RawRepresentable {}
extension BanubaUtilities.BackButtonConfiguration.Position : Swift.Equatable {}
extension BanubaUtilities.BackButtonConfiguration.Position : Swift.Hashable {}
extension BanubaUtilities.BackButtonConfiguration.Position : Swift.Sendable {}
extension BanubaUtilities.DrawableFigure : Swift.Equatable {}
extension BanubaUtilities.DrawableFigure : Swift.Hashable {}
extension BanubaUtilities.DrawableFigure : Swift.RawRepresentable {}
extension BanubaUtilities.GalleryItemType : Swift.Equatable {}
extension BanubaUtilities.GalleryItemType : Swift.Hashable {}
extension BanubaUtilities.GalleryItemType : Swift.RawRepresentable {}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Equatable {}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.Hashable {}
extension BanubaUtilities.SmallActivityIndicatorConfiguration.GradientTypeAdapter : Swift.RawRepresentable {}
extension BanubaUtilities.VideoResolution : Swift.Equatable {}
extension BanubaUtilities.VideoResolution : Swift.Hashable {}
extension BanubaUtilities.VideoResolution : Swift.RawRepresentable {}
extension BanubaUtilities.CameraVideoResolution : Swift.Equatable {}
extension BanubaUtilities.CameraVideoResolution : Swift.Hashable {}
extension BanubaUtilities.ImageFormat : Swift.Equatable {}
extension BanubaUtilities.ImageFormat : Swift.Hashable {}
